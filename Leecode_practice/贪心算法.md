# 贪心算法

## 贪心的本质

贪心的本质是选择每一阶段的局部最优，从而达到全局最优

## 贪心算法的解题步骤

贪心算法一般分为如下四步：

    将问题分解为若干个子问题
    找出适合的贪心策略
    求解每一个子问题的最优解
    将局部最优解堆叠成全局最优解
重点是可以通过局部最优，推算出全局最优

## 分发饼干

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子 i，都有一个胃口值  g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

### 分发饼干思路

- 对饼干和孩子胃口进行排序，大饼干分配给胃口大的孩子，依次同理，若s[j] < g[i]，则分配给下一位，以保证尽可能多的满足（遍历饼干，喂给最大的人，并标记去除）

```cpp
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        // 对数组进行排序（升序）
        sort(g.begin(), g.end());
        sort(s.begin(), s.end());
        // 对小孩进行for循环在外层，因为尽可能保证每个小孩获得最理想的饼干
        int index = s.size() - 1;
        int result = 0;
        for (int i = g.size() - 1; i >= 0; i--) {
            // 满足，index减1
            if (index >= 0 && g[i] <= s[index]) {
                result++;
                index--;
            }
        }
        return result;
    }
};
```

## 摆动序列

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。

例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3)  是正负交替出现的。相反, [1,4,7,2,5]  和  [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。

示例 1:

输入: [1,7,4,9,2,5]
输出: 6
解释: 整个序列均为摆动序列。
示例 2:

输入: [1,17,5,10,13,15,10,5,16,8]
输出: 7
解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。
示例 3:

输入: [1,2,3,4,5,6,7,8,9]
输出: 2

### 摆动序列思路

- 贪心思路--若出现坡度，肯定不是单调顺序，因此当遇到单调递增的趋势，就移动到下一个
- 为确保两边是正负号，因此要获取前后的差值，并判断是否为正负交替
- 特殊情况
  
  - 只有一个元素，默认摆动序列为1
  - 只有两个不相等的元素，也视为摆动元素，元素个数为2，由于前后梯度要保证计算有效，因此要对大小为二的进行单独处理
  - 当当遇到一种情况，上升平坡在上升的情况，由于梯度的不断更新，导致会多计算一个摆动元素，因此要设定，当遇到有效的摆动元素时，在对前坡度进行更新
    - 设定默认的前梯度为0；并且当前梯度等于0，后梯度为正/负时，也进行result++，

![specialCase](./fig/摆动序列特殊情况.png)

```cpp
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        // 只有一个元素，摆动序列默认为1
        if (nums.size() == 1) return 1;
        int prediff = 0; // 默认前边有一个虚拟节点，大小与第一个元素相同，确保两个元素也能计算出梯度
        int curdiff = 0; 
        int result = 1;
        for (int i = 0; i < nums.size() - 1; i++) {
            // 默认最后存在一个摆动
            // 更新现在梯度
            curdiff = nums[i + 1] - nums[i];
            if ((prediff >= 0 && curdiff < 0) || (prediff <= 0 && curdiff > 0)) {
                // 属于摆动序列，结果加1
                result++;
                // 在结果集中，因此要更新上一层梯度
                prediff = curdiff;
            }
        }
        return result;
    }
};
```

## 最大子序和

给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

示例:

输入: [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释:  连续子数组  [4,-1,2,1] 的和最大，为  6

### 最大子序和思路

- 贪心的思路，若已经累加的和为负数，那么这一段就是没有用的负数段，需要进行重置

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        // 结果设定为最小值，防止全负出现
        int result = INT_MIN;
        int count = 0; // 确定是否从新开始取数
        for (int i = 0; i < nums.size(); i++) {
            // 数字进行累加
            count += nums[i];
            if (count > result) result = count; // 更新最大值
            if (count < 0) count = 0; // 为负数时，直接进行初始化
        }
        return result;
    }
};
```

## 买卖股票的最佳时机 II

给定一个数组，它的第  i 个元素是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

示例 1:

输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
示例 2:

输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
示例  3:

输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
提示：

1 <= prices.length <= 3 * 10 ^ 4
0 <= prices[i] <= 10 ^ 4

### 买卖股票的最佳时机Ⅱ思路

- 贪心思路，将数组转换为差分数组，这样就类比于只收集正利润（）

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        vector<int> diff(prices.size() - 1, 0);
        for (int i = 1; i < prices.size(); i++) {
            diff[i - 1] = prices[i] - prices[i - 1];
        }
        int result = 0;
        for (int i = 0; i < diff.size(); i++) {
            result += max(diff[i], 0); // 只在正利润的时候，进行操作
        }
        return result;
    }
};
```

## 跳跃游戏

给定一个非负整数数组，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个位置。

示例  1:

输入: [2,3,1,1,4]
输出: true
解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。
示例  2:

输入: [3,2,1,0,4]
输出: false
解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。

### 跳跃游戏思路

- 不在于跳跃的过程，只在乎每一个节点所覆盖的范围

```cpp
class Solution {
public:
    bool canJump(vector<int>& nums) {
        // 定义一个cover范围，若重点在范围内，则返回true
        int cover = 0;
        if (nums.size() == 1) return true; // 防止只有一个元素，且大小为0
        for (int i = 0; i <= cover; i++) {
            // 从当前位置出发，看是否能到达终点，若大于说明可行
            cover = max(i + nums[i], cover);
            if (cover >= nums.size() - 1) {
                return true;
            }
        }
        return false;
    }
};
```

## 跳跃游戏 II

给定一个非负整数数组，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

你的目标是使用最少的跳跃次数到达数组的最后一个位置。

示例:

输入: [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。从下标为 0 跳到下标为 1 的位置，跳  1  步，然后跳  3  步到达数组的最后一个位置。
说明: 假设你总是可以到达数组的最后一个位置。

### 跳跃游戏Ⅱ思路

- 与一相比，不是时刻要更新最大的覆盖范围了，而是当覆盖范围走到尽头时，在进行更新，也就是看当前状态下能否走到终点
- 若不能，则多走一步

```cpp
class Solution {
public:
    int jump(vector<int>& nums) {
        // 当数组大小为1，且元素为0时，输出为零
        if (nums.size() == 1) return 0;
        // 创建变量，记录当前节点所能遍历的最大值和在当前节点再走一步所能走的最大值
        int cur = 0;
        int next = 0;
        int result = 0;
        for (int i = 0; i < nums.size(); i++) {
            // 更新当前节点再走一步所能遍历的最大范围
            next = max(next, i + nums[i]);
            // 如果当前的i==现在的范围
            if (i == cur) {
                // 更新next
                cur = next;
                result++; // 步数加1
                // 判断是否能到达终点
                if (cur >= nums.size() - 1) {
                    break;
                }
            }
        }
        return result;
    }
};
```

### 思路二

- 针对于方法一的特殊情况，可以统一处理，即：移动下标只要遇到当前覆盖最远距离的下标，直接步数加一，不考虑是不是终点的情况。

想要达到这样的效果，只要让移动下标，最大只能移动到 nums.size - 2 的地方就可以了。

因为当移动下标指向 nums.size - 2 时：

如果移动下标等于当前覆盖最大距离下标， 需要再走一步（即 ans++），因为最后一步一定是可以到的终点。（题目假设总是可以到达数组的最后一个位置）

```cpp
// 版本二
class Solution {
public:
    int jump(vector<int>& nums) {
        int curDistance = 0;    // 当前覆盖的最远距离下标
        int ans = 0;            // 记录走的最大步数
        int nextDistance = 0;   // 下一步覆盖的最远距离下标
        for (int i = 0; i < nums.size() - 1; i++) { // 注意这里是小于nums.size() - 1，这是关键所在
            nextDistance = max(nums[i] + i, nextDistance); // 更新下一步覆盖的最远距离下标
            if (i == curDistance) {                 // 遇到当前覆盖的最远距离下标
                curDistance = nextDistance;         // 更新当前覆盖的最远距离下标
                ans++;
            }
        }
        return ans;
    }
};
```

## K次取反后最大化的数组和

给定一个整数数组 A，我们只能用以下方法修改该数组：我们选择某个索引 i 并将 A[i] 替换为 -A[i]，然后总共重复这个过程 K 次。（我们可以多次选择同一个索引 i。）

以这种方式修改数组后，返回数组可能的最大和。

示例 1：

输入：A = [4,2,3], K = 1
输出：5
解释：选择索引 (1) ，然后 A 变为 [4,-2,3]。
示例 2：

输入：A = [3,-1,0,2], K = 3
输出：6
解释：选择索引 (1, 2, 2) ，然后 A 变为 [3,1,0,2]。
示例 3：

输入：A = [2,-3,-1,5,-4], K = 2
输出：13
解释：选择索引 (1, 4) ，然后 A 变为 [2,3,-1,5,4]。
提示：

1 <= A.length <= 10000
1 <= K <= 10000
-100 <= A[i] <= 100

### K次取反后最大化的数组和思路

- 先对数组进行以绝对值大小进行排列
- 贪心策略：①优先对绝对值最大的负数进行取反 ②若负数取完后，k仍有余量，则判断是否为奇数，若为奇数，将绝对值最小的正数取反即可

```cpp
class Solution {
public:
    static bool compare(int a, int b) {
        return abs(a) > abs(b);
    }
    int largestSumAfterKNegations(vector<int>& nums, int k) {
        sort(nums.begin(), nums.end(), compare);
        for (int i = 0; i < nums.size(); i++) {
            // 优先对负数进行取反
            if (nums[i] < 0 && k > 0) {
                nums[i] *= -1;
                k--;
            }
        }
        // 若还存在k，最对正数的最小值取反（奇数）
        if (k % 2 == 1) nums[nums.size() - 1] *= -1;
        // 计算数组和
        int reusult = 0;
        for (int i = 0; i < nums.size(); i++) reusult += nums[i];
        // 返回结果
        return reusult;
    }
};
```

## 加油站

在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。

你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。

如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。

说明:

如果题目有解，该答案即为唯一答案。
输入数组均为非空数组，且长度相同。
输入数组中的元素均为非负数。
示例 1: 输入:

gas = [1,2,3,4,5]
cost = [3,4,5,1,2]
输出: 3 解释:

从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
因此，3 可为起始索引。
示例 2: 输入:

gas = [2,3,4]

cost = [3,4,3]

输出: -1

解释: 你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油。开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油。开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油。你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。因此，无论怎样，你都不可能绕环路行驶一周。

### 加油站思路

- 贪心策略：若从某个站点开始为止，剩余汽油不足以到达下一个站点，则从下一个站点开始为止
  - 若从上一个站点开始，油量为负，那么
  - 如果 curSum<0 说明 区间和1 + 区间和2 < 0， 那么 假设从上图中的位置开始计数curSum不会小于0的话，就是 区间和2>0。

区间和1 + 区间和2 < 0 同时 区间和2>0，只能说明区间和1 < 0， 那么就会从假设的箭头初就开始从新选择起始位置了。

那么局部最优：当前累加rest[i]的和curSum一旦小于0，起始位置至少要是i+1，因为从i之前开始一定不行。全局最优：找到可以跑一圈的起始位置。

局部最优可以推出全局最优，找不出反例，试试贪心！

```cpp
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        // 定义一个从某站点开始累加的油量，与从开始站点累加的油量
        int curSum = 0;
        int totalSume = 0;
        int start = 0;
        for (int i = 0; i < gas.size(); i++) {
            // 记录从这个结点开始，剩余油量
            curSum += gas[i] - cost[i];
            totalSume += (gas[i] - cost[i]);
            if (curSum < 0) {
                curSum = 0;
                start = i + 1;
            }
    }
    if (totalSume < 0) return -1;
    return start;
    }
};
```

## 分发糖果

老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。

你需要按照以下要求，帮助老师给这些孩子分发糖果：

每个孩子至少分配到 1 个糖果。
相邻的孩子中，评分高的孩子必须获得更多的糖果。
那么这样下来，老师至少需要准备多少颗糖果呢？

示例 1:

输入: [1,0,2]
输出: 5
解释: 你可以分别给这三个孩子分发 2、1、2 颗糖果。
示例 2:

输入: [1,2,2]
输出: 4
解释: 你可以分别给这三个孩子分发 1、2、1 颗糖果。第三个孩子只得到 1 颗糖果，这已满足上述两个条件。

### 分发糖果思路

- 定一移二，先保证一边在进行另一边的逻辑处理
- 最后遍历时，要进行状态的更新，即满足两边都成立的最大值

```cpp
class Solution {
public:
    int candy(vector<int>& ratings) {
        // 初始值均为1
        vector<int> result(ratings.size(), 1);
        // 从两边分别遍历，更新为值大的糖果也要多，因此最后的遍历要取两次遍历的最大值
        for (int i = 1; i < ratings.size(); i++) {
            if (ratings[i] > ratings[i - 1]) {
                result[i] = result[i - 1] + 1;
            }
        }
        int sum = result[result.size() - 1];
        // 反向遍历，更新状态值
        for (int i = ratings.size() - 2; i >= 0; i--) {
            if (ratings[i] > ratings[i + 1]) {
                result[i] = max(result[i], result[i + 1] + 1);
            }
            sum += result[i];
        }
        return sum;

    }
};
```

## 柠檬水找零

在柠檬水摊上，每一杯柠檬水的售价为 5 美元。

顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。

每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。

注意，一开始你手头没有任何零钱。

如果你能给每位顾客正确找零，返回 true ，否则返回 false 。

示例 1：

输入：[5,5,5,10,20]
输出：true
解释：
前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。
第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。
第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。
由于所有客户都得到了正确的找零，所以我们输出 true。
示例 2：

输入：[5,5,10]
输出：true
示例 3：

输入：[10,10]
输出：false
示例 4：

输入：[5,5,10,10,20]
输出：false
解释：
前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。
对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。
对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。
由于不是每位顾客都得到了正确的找零，所以答案是 false。
提示：

0 <= bills.length <= 10000
bills[i] 不是 5 就是 10 或是 20

### 柠檬水找零思路

- 尽可能留小额钞票，将大额钞票花出去

```cpp
class Solution {
public:
    bool lemonadeChange(vector<int>& bills) {
        // 定义5，10，20的数目
        int five = 0, ten = 0, twenty = 0;
        // 优先用大额钞票进行找零
        for (int bill : bills) {
            if (bill == 5) five++;
            else if (bill == 10) {
                if (five > 0) {
                    five--;
                    ten++;
                } else return false;
            }
            else {
                if ((ten > 0 && five) > 0)
                {
                    ten--;
                    five--;
                    twenty++;
                } else if (five >= 3) {
                    five -= 3;
                } else return false;
            }
        }
        return true; 
    }
};
```

## 根据身高重建队列

假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。

请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。

示例 1：

输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
解释：
编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。
编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。
编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。
编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。
编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。
示例 2：

输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]
输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]
提示：

1 <= people.length <= 2000
0 <= hi <= 10^6
0 <= ki < people.length
题目数据确保队列可以被重建

### 根据身高重建队列思路

- 按照身高从大到小排序，身高相同的人，k值小的排在前面
- 创建一个新的数组，防止插入后导致数据紊乱，按照k的值进行插入，若k小则往前（由于身高靠后，无影响）

```cpp
class Solution {
public:
    static bool cmp (vector<int>& people1, vector<int>& people2) {
        if (people1[0] == people2[0]) return people1[1] < people2[1];
        return people1[0] > people2[0];
    } 
    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
        sort(people.begin(), people.end(), cmp);
        vector<vector<int>> queue;
        for (int i = 0; i < people.size(); i++) {
            // 根据身高大小从大到小排列，因此当前边身高高的人大于指定数字时，可以插入
            // 因为身高没有比前边的人高，插入毫无影响
            int position = people[i][1];
            queue.insert(queue.begin() + position, people[i]);
        }
        return queue;
    }
};
```

#### vector底层讲解

首先vector的底层实现也是普通数组。

vector的大小有两个维度一个是size一个是capicity，size就是我们平时用来遍历vector时候用的

当insert数据的时候，如果已经大于capicity，capicity会成倍扩容，但对外暴漏的size其实仅仅是+1。

那么既然vector底层实现是普通数组，怎么扩容的？

就是重新申请一个二倍于原数组大小的数组，然后把数据都拷贝过去，并释放原数组内存。（对，就是这么原始粗暴的方法！）

## 用最少数量的箭引爆气球

在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。

一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。

给你一个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。

示例 1：

输入：points = [[10,16],[2,8],[1,6],[7,12]]
输出：2
解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球
示例 2：

输入：points = [[1,2],[3,4],[5,6],[7,8]]
输出：4
示例 3：

输入：points = [[1,2],[2,3],[3,4],[4,5]]
输出：2
示例 4：

输入：points = [[1,2]]
输出：1
示例 5：

输入：points = [[2,3],[2,3]]
输出：1
提示：

0 <= points.length <= 10^4
points[i].length == 2
-2^31 <= xstart < xend <= 2^31 - 1

### 用最少数量的箭引爆气球思路

- 先对输入数组进行排序，按照xstart进行排序
- 首先判断前后两个的右边界是否重叠（当前的start是否小于上一个的end），若大于则需要两支箭
- 当小于时，需判断下一个是否也可以通过一个箭射下，则需要更新右边界（上两个的最小右边界）更新以保证下一个的使用

```cpp
class Solution {
public:
    static bool cmp(vector<int>& a, vector<int>& b) {
        return a[0] < b[0];
    }
    int findMinArrowShots(vector<vector<int>>& points) {
        // 默认一支箭
        int result = 1;
        // 先按照左边界进行排序
        sort(points.begin(), points.end(), cmp);
        for (int i = 1; i < points.size(); i++) {
            // 首先判断，这两个是否存在交集，可以用一支箭
            if (points[i][0] > points[i - 1][1]) {
                result++;
            } else {
                // 可以用一支箭，更新当前节点的右边界
                points[i][1] = min(points[i][1], points[i - 1][1]);
            }
        }
        return result;
    }
};
```

## 无重叠区间

给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。

注意: 可以认为区间的终点总是大于它的起点。 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。

示例 1:

输入: [ [1,2], [2,3], [3,4], [1,3] ]
输出: 1
解释: 移除 [1,3] 后，剩下的区间没有重叠。
示例 2:

输入: [ [1,2], [1,2], [1,2] ]
输出: 2
解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。
示例 3:

输入: [ [1,2], [2,3] ]
输出: 0
解释: 你不需要移除任何区间，因为它们已经是无重叠的了。

### 无重叠区间思路

- 与上一题的思路相似

```cpp
class Solution {
public:
    static bool cmp (vector<int>& a, vector<int>& b) {
        return a[0] < b[0];
    }
    int eraseOverlapIntervals(vector<vector<int>>& intervals) {
        int result = 0;
        sort(intervals.begin(), intervals.end(), cmp);
        for (int i = 1; i < intervals.size(); i++) {
            if (intervals[i][0] < intervals[i - 1][1]) {
                result++;
                // 更新右边界，确定删除哪一个，以保证最小
                intervals[i][1] = min(intervals[i - 1][1], intervals[i][1]);
            }
    }
    return result;
    }
};
```

## 划分字母区间

字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个V片段中。返回一个表示每个字符串片段的长度的列表。

示例：

输入：S = "ababcbacadefegdehijhklij"
输出：[9,7,8] 解释： 划分结果为 "ababcbaca", "defegde", "hijhklij"。 每个字母最多出现在一个片段中。 像 "ababcbacadefegde", "hijhklij" 的划分是错误的，因为划分的片段数较少。
提示：

S的长度在[1, 500]之间。
S只包含小写字母 'a' 到 'z' 。

### 划分字母区间思路

- 找到每一个字母出现的最大右边界
- 遍历整个数组，当出现新字母时，遍历最大右边界
- 若当前的i等于最大右边界，则说明当前的字母已经遍历完，进行下一轮的遍历

```cpp
class Solution {
public:
    vector<int> partitionLabels(string s) {
        int hash[27];
        for (int i = 0; i < s.size(); i++) {
            hash[s[i] - 'a'] = i;
        }
        vector<int> count;
        int right = 0;
        int left = 0;
        for (int i = 0; i < s.size(); i++) {
            right = max(hash[s[i] - 'a'], right);
            if (right == i) {
                int length = (right + 1 - left);
                count.push_back(length);
                left = right + 1;
            }
        }
        return count;
    }
};
```

## 合并区间

以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。

 

示例 1：

输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
示例 2：

输入：intervals = [[1,4],[4,5]]
输出：[[1,5]]
解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。

### 合并区间思路

- 先对输入数组进行排序，按照start进行排序
- 创建一个新的结果集，若重叠，则对最后一个元素的右边界进行更新
- 若不重叠，则将当前元素加入结果集

```cpp
class Solution {
public:
    static bool cmp(vector<int>& a, vector<int>& b) {
        return a[0] < b[0];
    }
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        // 按照起始区间排序
        sort(intervals.begin(), intervals.end(), cmp);
        // 创建一个新的队列，防止操作复杂
        vector<vector<int>> result;
        result.push_back(intervals[0]); // 放入第一个进行初始
        for (int i = 1; i < intervals.size(); i++) {
            // 判断当前的左区间与result最后一个的右区间
            if(intervals[i][0] <= result.back()[1]) {
                // 更新区间
                result.back()[1] = max(result.back()[1], intervals[i][1]);
            } else {
                result.push_back(intervals[i]);
            }
        }
        return result;
    }
};
```

## 单调递增的数字

给定一个非负整数 N，找出小于或等于 N 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。

（当且仅当每个相邻位数上的数字 x 和 y 满足 x <= y 时，我们称这个整数是单调递增的。）

示例 1:

输入: N = 10
输出: 9
示例 2:

输入: N = 1234
输出: 1234
示例 3:

输入: N = 332
输出: 299
说明: N 是在 [0, 10^9] 范围内的一个整数。

### 单调递增的数字思路

- 为方便处理将int转换为string
- 在最大值的基础上，从后向前遍历，若前一位大于后一位，则对前一位减一，并且对后边的位数全部置9
- 若前一位小于等于后一位，则不变
- 记录flag出现的位置，保证flag之后全部变成9

```cpp
class Solution {
public:
    int monotoneIncreasingDigits(int n) {
        string s = to_string(n);
        int flag = s.size();
        for (int i = s.size() - 1; i > 0; i--) {
            if (s[i - 1] > s[i]) {
                s[i - 1]--;
                flag = i;
            }
        }
        // 对flag位以后的全部置9
        for (int i = flag; i < s.size(); i++) {
            s[i] = '9';
        }
        return stoi(s);
    }
};
```

## 监控二叉树

给定一个二叉树，我们在树的节点上安装摄像头。

节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。

计算监控树的所有节点所需的最小摄像头数量。

### 监控二叉树

- 贪心策略--从叶子节点出发，在叶子节点的上一层放摄像头，然后每隔一个两个放一个摄像头
- 从叶子节点出发，因此采用后序遍历(左右中)
- 有限状态机，0未被覆盖，1有摄像头，2被覆盖
  - 特殊叶子结点的状态是什么--被覆盖（0-需要叶子节点装摄像头，1-叶子节点的上一层将不能被覆盖）
  - 左右都有覆盖（上下肯定有一个是摄像头，）
  - 左右都没有覆盖（上下都没有摄像头，）
  - 左右有一个没有覆盖（上下有一个摄像头）

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
private: 
    int result = 0;
    int backTracing(TreeNode* root) {
        if (root == nullptr) return 2;
        int nodeLeft = backTracing(root->left);
        int nodeRight = backTracing(root->right);
        if (nodeLeft == 2 && nodeRight == 2) return 0;
        else if (nodeLeft == 0 || nodeRight == 0) {
            result++;
            return 1;
        } else return 2;
        return -1;
    }

public:
    
    int minCameraCover(TreeNode* root) {
        result = 0;
        int state = backTracing(root);
        if (state == 0) {
            // root无覆盖
            result++;
        }
        return result;
    }
};
```
