# 回溯算法

DP数组含义

## 模板

- 确定dp数组的含义
- 确定递推公式
- 确定dp数组的初始化
- 确定遍历顺序
- 打印dp数组(用于调试)

## 斐波那契数

斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n > 1 给你n ，请计算 F(n) 。

### 斐波那契数思路

- dp[i] 表示第i个斐波那契数的值
- 递推公式
- 特殊值处理

```cpp
class Solution {
public:
    int fib(int n) {
        if (n == 0) return 0;
        vector<int> dp(n + 1, 0);
        dp[0] = 0;
        dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];

    }
};
```

## 爬楼梯

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

### 爬楼梯思路

- dp[i] 表示爬到第i个台阶的方法数
- 递推公式，i台阶可以通过i-1和i-2台阶的方式爬到
- 特殊值处理，n=1时，只有一种方法，即爬1个台阶
- 打印dp数组(用于调试)

```cpp
class Solution {
public:
    int climbStairs(int n) {
        // 判断特殊值，防止耗时
        if (n == 1) return 1;
        if (n == 2) return 2;
        vector<int> dp(n + 1, 0);
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
};
```

## 使用最小花费爬楼梯

后来力扣改了题目描述，新题目描述：

给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。

请你计算并返回达到楼梯顶部的最低花费。

### 使用最小花费爬楼梯思路

- dp含义--到达第i个台阶所需的最小花费
- 初始化，只需初始化第一个和第二个台阶

```cpp
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        // 确定dp数组含义，到达i步所需的最小费用
        vector<int> dp(cost.size() + 1, 0);
        // 实际上台阶有i+1个，因为跳起来才有花费
        for (int i = 2; i <= cost.size(); i++) {
            dp[i] = min(dp[i - 2] + cost[i - 2], dp[i - 1] + cost[i - 1]);
        }
        return dp[dp.size() - 1];
    }
};
```

## 不同路径

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

### 不同路径思路

- dp[i][j] 表示从起点到达i,j位置的路径数
- 递推公式，到达i,j位置的路径数等于到达i-1,j的路径数和到达i,j-1的路径数的和
- 特殊值处理，到达i,0位置只有一条路径，到达0,j位置只有一条路径(初始化)

```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> dp(m, vector<int> (n, 0)); 
        // 横着一行，竖着一列，全部只有一种方式
        for (int i = 0; i < m; i++) {
            dp[i][0] = 1;
        }
        for (int j = 0; j < n; j++) {
            dp[0][j] = 1;
        }
        // dp含义，到达第i行，第j列的不同路径数
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
};
```

## 不同路径 II

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

### 不同路径 II思路

- dp[i][j] 表示从起点到达i,j位置的路径数
- 因为存在障碍物，同时机器人只能向下或者向右运动，因此当(i , j)存在障碍物时，无法继续前进(即dp[i][j] = 0)

```cpp
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        // 如果起点或终点出现了障碍物，则返回
        if (obstacleGrid[0][0] == 1 || 
            obstacleGrid[obstacleGrid.size() - 1][obstacleGrid[0].size() - 1] == 1) {
                return 0;
            }
            
        // dp数组含义，到达(i, j)共有多少条路径
        vector<vector<int>> dp(obstacleGrid.size(), vector<int> (obstacleGrid[0].size(), 0));
        // 对第一列进行初始化
        for (int i = 0; i < obstacleGrid.size() && obstacleGrid[i][0] == 0;
             i++) {
                dp[i][0] = 1;
             }
        // 对第一行进行初始化
        for (int j = 0; j < obstacleGrid[0].size() && obstacleGrid[0][j] == 0;
             j++) {
            dp[0][j] = 1;
        }

        // 进行递推公式迭代
        for (int i = 1; i < obstacleGrid.size(); i++) {
            for (int j = 1; j < obstacleGrid[0].size(); j++) {
                // 判断前方是否存在障碍物
                if (obstacleGrid[i][j] == 1) continue; // dp默认值为0
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[obstacleGrid.size() - 1][obstacleGrid[0].size() - 1];
    }
};
```

## 整数拆分

给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。

### 整数拆分思路

- dp[i] 表示将n拆分成至少i个正整数的最大乘积
- 递推公式，由于dp[i]代表着拆分为至少2个正整数的最大值，所以需要判断两个还是多个最佳
- 特殊值处理，n=1时，最大乘积为1
- $max(j * dp[i - j], j * (i -j))$

```cpp
class Solution {
public:
    int integerBreak(int n) {
        if (n == 2) return 1;
        // 确定dp数组的含义，将i拆分所得的最大值
        vector<int> dp(n + 1, 0);
        // 初始化dp数组
        dp[0] = 0;
        dp[1] = 0;
        dp[2] = 1;
        for (int i = 3; i <= n; i++) {
            for (int j = 1; j < i; j++) {
                dp[i] = max(max(j * (i - j), j * dp[i - j]), 
                            dp[i]); // 在两个数与三个数之间取最大值
            }
        }
        return dp[n];
    }
};
```

## 不同的二叉搜索树

给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？

### 不同的二叉搜索树思路

- dp[i] 表示以i个节点组成的二叉搜索树的个数
- dp[i] 可以依次表示为左边共有dp[j - 1] 右边共有[i - j]

```cpp
class Solution {
public:
    int numTrees(int n) {
        // dp数组含义，整数n下的二叉搜索树种类
        vector<int> dp(n + 1);
        // 初始化dp数组
        dp[0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= i; j++) {
                dp[i] += dp[j - 1] * dp[i - j];
            } 
        }
        return dp[n];
    }
};
```

## 背包问题

小明是一位科学家，他需要参加一场重要的国际科学大会，以展示自己的最新研究成果。他需要带一些研究材料，但是他的行李箱空间有限。这些研究材料包括实验设备、文献资料和实验样本等等，它们各自占据不同的空间，并且具有不同的价值。 

小明的行李空间为 N，问小明应该如何抉择，才能携带最大价值的研究材料，每种研究材料只能选择一次，并且只有选与不选两种选择，不能进行切割。

## 遍历顺序

根据状态转移方程确定遍历顺序，二维的先遍历物品还是背包是可以互换的，但三维的不行，根据状态转移方程可知。


### 01背包问题解题思路

- n种物品，每种只有一个
- dp[i][j] 表示0，i的物品任取放容量为j的背包（已经存在的物品重量）里所能达到的最大价值
- dp[i - 1][j - weight[i]]  + value[i](放物品i)
- dp[i - 1][j] 不放物品i

## 分割等和子集

给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

注意: 每个数组中的元素不会超过 100 数组的大小不会超过 200

### 分割等和子集思路

- 转化为01背包问题，物品的价值与重量等值，若dp[j] == j,则说明发现了一个组合可以让他们相等
- 如果总和除以2，有余数，则说明不可能
- 目标是让背包装满的情况下，其价值等于容量

```cpp
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0, target = 0;
        for (int i = 0; i < nums.size(); i++) sum += nums[i];
        if (sum % 2 != 0) return false;
        target = sum / 2;
        vector<int> dp(target + 1, 0);
        // 先遍历物品后遍历背包，防止滚动数组对dp[j]进行覆盖
        for (int i = 0; i < nums.size(); i++) {
            for (int j = target; j >= nums[i]; j--) {
                // 更新dp值,是否放nums[i]
                dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);
            }
        }

        if (dp[target] == target) return true;
        return false;
    }
};
```

## 最后一块石头的重量II有一堆石头，每块石头的重量都是正整数。

每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：

如果 x == y，那么两块石头都会被完全粉碎；

如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。

最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回 0。

### 最后一块石头的重量II思路

- 与上一题相似，将一堆石头尽可能地分成两堆，然后sum - 2 * max()

```cpp
class Solution {
public:
    int lastStoneWeightII(vector<int>& stones) {
        int sum = 0, target = 0;
        for (int i = 0; i < stones.size(); i++) sum += stones[i];
        target = sum / 2;
        // 定义dp数组
        vector<int> dp(target + 1, 0);
        // 遍历更新dp数组
        for (int i = 0; i < stones.size(); i++) {
            for (int j = target; j >= stones[i]; j--) {
                dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);
            }
        }
        // 返回差值
        return sum - 2 * dp[target];
    }
};
```

## 目标和

给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。

返回可以使最终数组和为目标数 S 的所有添加符号的方法数。

### 目标和思路

- 根据公式转换，将组合问题调整到背包问题当中
- 根据01背包问题，将物品填入到背包中获取left的最大数目

```cpp
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        int sum = 0;
        for (int i = 0; i < nums.size(); i++) sum += nums[i];
        if ((target + sum) % 2 == 1) return 0;
        if (abs(target) > sum) return 0;

        int left = (target + sum) / 2;
        // 创建dp数组
        // 当i = 0时，dp[0] = 0；表征未加入元素时的方法共有一种
        vector<int> dp(left + 1, 0);
        dp[0] = 1;
        // 判断装满left的背包的数目
        for (int i = 0; i < nums.size(); i++) {
            // 倒序，因为i是01背包，每一个物品只能放一个
            for (int j = left; j >= nums[i]; j--) {
                dp[j] += dp[j - nums[i]]; 
                // 放背包里面的物品，已经有了nums[i]之后还有几种方法可以凑成j - nums[i]
            }
        }
        return dp[left];
    }
};
```

## 一和零

给你一个二进制字符串数组 strs 和两个整数 m 和 n 。

请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。

如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。

### 一和零思路

- dp扩展为二维，i个0容量与j个1容量下最多能容纳多少个字符串
- 递推公式，dp[i][j] = dp[i - string[0][i]][j - string[1][i]] + 1 与不加这个字符串的最大值(当前字符串包含1个1)

```cpp
class Solution {
public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        // 创建dp数组（二维，第一维表示0的容量，第二维表示1的容量）
        vector<vector<int>> dp(m + 1, vector<int> (n + 1, 0));
        // 遍历获得每一个字符串的0，1个数
        for (string s : strs) {
            int x = 0, y = 0;
            for (char c : s) {
                if (c == '0') {
                    x++;
                } else {
                    y++;
                }
            }
            // 遍历背包
            for (int i = m; i >= x; i--) {
                for (int j = n; j >= y; j--) {
                    dp[i][j] = max(dp[i - x][j - y] + 1, dp[i][j]);
                }
            }
        }
        return dp[m][n];
    }
};
```

## 完全背包理论基础

有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品都有无限个（也就是可以放入背包多次），求解将哪些物品装入背包里物品价值总和最大。

完全背包和01背包问题唯一不同的地方就是，每种物品有无限件
完全背包的物品是可以添加多次的，所以遍历背包容量要从小到大去遍历，

## 零钱兑换II

给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。

### 零钱兑换Ⅱ

- 确定dp数组含义，dp[i]表示凑够金额i的组合种类数
- 遍历顺序--由于一个物品可以多次放入
- 递推公式--当背包里面已经有coins[i]时，还需要j - coins[i]的组合数

### 评论解答

关于组合和排列的问题还是有些不解。以下仅为自己的理解：先遍历物品后遍历背包是这样，比如，外层循环固定coins【1】，在内层循环遍历背包时，随着背包不断增加，coins【1】可以重复被添加进来，而由于外层循环固定了，因此coins【2】只能在下一次外层循环添加进不同大小的背包中，这么看的话，coins【i+1】只能在coins【i】之后了；如果先遍历背包后遍历物品，那么外层循环先固定背包大小j，然后在大小为j的背包中循环遍历添加物品，然后在下次外层循环背包大小变为j+1，此时仍要执行内层循环遍历添加物品，也就会出现在上一轮外层循环中添加coins【2】的基础上还能再添加coins【1】的情况，那么就有了coins【1】在coins【2】之后的情况了。

```cpp
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        // 初始化dp数组
        vector<int> dp(amount + 1, 0);
        // 当amount = 0时，共有一种组合方式
        dp[0] = 1;
        // 更新dp数组
        for (int i = 0; i < coins.size(); i++) {
            // 先遍历物品，再遍历背包
            for (int j = coins[i]; j <= amount; j++) {
                if (dp[j] < INT_MAX - dp[j - coins[i]]) {
                    dp[j] += dp[j - coins[i]];
                }  
            }
        }
        return dp[amount];
    }
};
```

## 组合总和 Ⅳ

给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。
扩展：类比于爬楼梯问题，先爬1在爬2和先爬2在爬1是两种不一样的方法

### 组合总和 Ⅳ思路

- 与上一题的思路一致，上一题是组合问题，但在该题目为排列问题，不一样的顺序是不同的结果

```cpp
class Solution {
public:
    int combinationSum4(vector<int>& nums, int target) {
        // 定义dp数组
        vector<int> dp(target + 1, 0);
        // 当target等于0时，dp[0] = 1
        dp[0] = 1;
        for (int i = 0; i <= target; i++) {
            // 组合问题，先背包后物品
            for (int j = 0; j < nums.size(); j++) {
                if (i - nums[j] >= 0 && 
                    dp[i] <= INT_MAX - dp[i - nums[j]]) {
                    dp[i] += dp[i - nums[j]];
                }
            }
        }
        return dp[target];
    }
};
```

## 零钱兑换

给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

你可以认为每种硬币的数量是无限的。

### 零钱兑换思路

- 确定dp数组含义，dp[i]表示凑够金额i的最少硬币数
- dp数组初始化
- 遍历硬币，更新dp数组
- dp[i] = min(dp[i], dp[i - coins[j]] + 1)
- 遍历顺序，顺序与最少无关

```cpp
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        // 初始化dp数组，由于取最小，全部初始化为INT_MAX
        vector<int> dp(amount + 1, INT_MAX);
        // 对于dp[0]大小为0
        dp[0] = 0;
        // 遍历顺序，一个物品可以放多次，同时组合而不是排列
        for (int i = 0; i < coins.size(); i++) {
            for (int j = coins[i]; j <= amount; j++) {
                if (dp[j - coins[i]] != INT_MAX) {
                    dp[j] = min(dp[j - coins[i]] + 1, dp[j]);
                }
            }
        }
        if (dp[amount] == INT_MAX) return -1;
        return dp[amount];
    }
};
```

## 完全平方数

给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16,...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。

### 完全平方数思路

- 确定dp数组含义，dp[i]表示凑够i的最少完全平方数个数
- dp数组初始化（dp[0] = 0）同时所有的值赋给最大值，保证min触发
- 遍历i，更新dp数组
- dp[i] = min(dp[i], dp[i - j * j] + 1)
- 遍历顺序，顺序与最少无关

```cpp
class Solution {
public:
    int numSquares(int n) {
        // 确定dp数组,由于求最小值，因此初始化为INT_MAX
        vector<int> dp(n + 1, INT_MAX);
        // 初始化dp数组
        dp[0] = 0;
        // 算最小，因此是组合问题,遍历顺序无关
        // 由于另一个整数的多平方，所以物品需要从1开始
        for (int i = 1; i * i <= n; i++) {
            for (int j = i * i; j <= n; j++) {
                dp[j] = min(dp[j - i * i] + 1, dp[j]);
            }
        }
        return dp[n];
    }
};
```

## 单词拆分

给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。

说明：

拆分时可以重复使用字典中的单词。

你可以假设字典中没有重复的单词。

### 单词拆分思路

- 定义dp数组，dp[i]表示s[0:i]是否可以被字典中的单词拆分
- dp[0]为False，因为空字符串无法被拆分
- 只有正常顺序被拆分和不能被拆分，因此是排列问题，顺序影响结果
- 从背包的第零位出发，遍历s，判断该单词是否能在worddict中
- 若存在，则判断dp[j]是否为true

```cpp
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        // 定义哈希表，快速查找，提高效率
        unordered_set<string> wordSet(wordDict.begin(), wordDict.end());
        // 定义dp数组
        vector<bool> dp(s.size() + 1, false);
        // 初始化dp数组
        dp[0] = true;
        // 遍历，组合问题，顺序无关
        for (int i = 1; i <= s.size(); i++) {
            for (int j = 0; j < i; j++) { 
                string tmp = s.substr(j, i - j);
                if (wordSet.find(tmp) != wordSet.end() && dp[j] != false) {
                    dp[i] = true;
                }
            }
        }
        return dp[s.size()];
    }
};
```

## 多重背包

**了解即可**
对于多重背包，我在力扣上还没发现对应的题目，所以这里就做一下简单介绍，大家大概了解一下。

有N种物品和一个容量为V 的背包。第i种物品最多有Mi件可用，每件耗费的空间是Ci ，价值是Wi 。求解将哪些物品装入背包可使这些物品的耗费的空间 总和不超过背包容量，且价值总和最大。

多重背包和01背包是非常像的， 为什么和01背包像呢？

每件物品最多有Mi件可用，把Mi件摊开，其实就是一个01背包问题了。

## 背包问题总结

如果求组合数就是外层for循环遍历物品，内层for遍历背包。

如果求排列数就是外层for遍历背包，内层for循环遍历物品。

## 打家劫舍

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

### 打家劫舍思路

- 确定dp数组含义，dp[i]表示偷窃到i房屋的最高金额
- 初始化dp[0] = nums[0] （题目中明确nums.size() >= 1），dp[1] = max(nums[0], nums[1])
- 递推公式，dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])

```cpp  
class Solution {
public:
    int rob(vector<int>& nums) {
        if (nums.size() == 1) return nums[0];
        // dp数组含义，共有i个屋子下所能偷到的最高金额
        vector<int> dp(nums.size(), 0);
        // 初始化dp数组
        dp[0] = nums[0];
        dp[1] = max(nums[0], nums[1]);
        for (int i = 2; i < nums.size(); i++) {
            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);
        }
        return dp[nums.size() - 1];
    }
};
```

## 打家劫舍II

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。

给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，能够偷窃到的最高金额。

### 打家劫舍II思路

- 拆分三种情况，然后取最大值即可
- 第一种不考虑首尾（已经被第二三种方法包含在内了）
- 第二三种，不考虑首/尾
- 思路同打家劫舍

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        if (nums.size() == 0) return 0;
        if (nums.size() == 1) return nums[0];
        int result1 = robRange(nums, 0, nums.size() - 2); // 情况二
        int result2 = robRange(nums, 1, nums.size() - 1); // 情况三
        return max(result1, result2);
    }
    // 198.打家劫舍的逻辑
    int robRange(vector<int>& nums, int start, int end) {
        if (end == start) return nums[start];
        vector<int> dp(nums.size());
        dp[start] = nums[start];
        dp[start + 1] = max(nums[start], nums[start + 1]);
        for (int i = start + 2; i <= end; i++) {
            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
        }
        return dp[end];
    }
};
```

## 打家劫舍 III

在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。

计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。

### 打家劫舍 III思路

- 遇到二叉树，考虑递归三部曲为主框架
- 递归函数返回值，为当前节点偷还是不偷的值（由于需要确定子节点不偷还是偷的值，因此采用后序遍历）
- 递归函数参数，父节点
- 返回值dp[1],dp[0]

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> backTracing(TreeNode* cur) {
        if (cur == nullptr) return vector<int> (2, 0);
        vector<int> leftval = backTracing(cur->left);
        vector<int> rightval = backTracing(cur->right);
        int val_not = max(leftval[0], leftval[1]) + max(rightval[0], rightval[1]);
        int val_is = cur->val + leftval[0] + rightval[0];
        return vector<int> {val_not, val_is};
    }
    int rob(TreeNode* root) {
        vector<int> results;
        results = backTracing(root);
        return max(results[0], results[1]);
    }
};
```