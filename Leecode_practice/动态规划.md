# 回溯算法

DP数组含义

## 模板

- 确定dp数组的含义
- 确定递推公式
- 确定dp数组的初始化
- 确定遍历顺序
- 打印dp数组(用于调试)

## 斐波那契数

斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n > 1 给你n ，请计算 F(n) 。

### 斐波那契数思路

- dp[i] 表示第i个斐波那契数的值
- 递推公式
- 特殊值处理

```cpp
class Solution {
public:
    int fib(int n) {
        if (n == 0) return 0;
        vector<int> dp(n + 1, 0);
        dp[0] = 0;
        dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];

    }
};
```

## 爬楼梯

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

### 爬楼梯思路

- dp[i] 表示爬到第i个台阶的方法数
- 递推公式，i台阶可以通过i-1和i-2台阶的方式爬到
- 特殊值处理，n=1时，只有一种方法，即爬1个台阶
- 打印dp数组(用于调试)

```cpp
class Solution {
public:
    int climbStairs(int n) {
        // 判断特殊值，防止耗时
        if (n == 1) return 1;
        if (n == 2) return 2;
        vector<int> dp(n + 1, 0);
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
};
```

## 使用最小花费爬楼梯

后来力扣改了题目描述，新题目描述：

给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。

请你计算并返回达到楼梯顶部的最低花费。

### 使用最小花费爬楼梯思路

- dp含义--到达第i个台阶所需的最小花费
- 初始化，只需初始化第一个和第二个台阶

```cpp
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        // 确定dp数组含义，到达i步所需的最小费用
        vector<int> dp(cost.size() + 1, 0);
        // 实际上台阶有i+1个，因为跳起来才有花费
        for (int i = 2; i <= cost.size(); i++) {
            dp[i] = min(dp[i - 2] + cost[i - 2], dp[i - 1] + cost[i - 1]);
        }
        return dp[dp.size() - 1];
    }
};
```

## 不同路径

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

### 不同路径思路

- dp[i][j] 表示从起点到达i,j位置的路径数
- 递推公式，到达i,j位置的路径数等于到达i-1,j的路径数和到达i,j-1的路径数的和
- 特殊值处理，到达i,0位置只有一条路径，到达0,j位置只有一条路径(初始化)

```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> dp(m, vector<int> (n, 0)); 
        // 横着一行，竖着一列，全部只有一种方式
        for (int i = 0; i < m; i++) {
            dp[i][0] = 1;
        }
        for (int j = 0; j < n; j++) {
            dp[0][j] = 1;
        }
        // dp含义，到达第i行，第j列的不同路径数
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
};
```

## 不同路径 II

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

### 不同路径 II思路

- dp[i][j] 表示从起点到达i,j位置的路径数
- 因为存在障碍物，同时机器人只能向下或者向右运动，因此当(i , j)存在障碍物时，无法继续前进(即dp[i][j] = 0)

```cpp
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        // 如果起点或终点出现了障碍物，则返回
        if (obstacleGrid[0][0] == 1 || 
            obstacleGrid[obstacleGrid.size() - 1][obstacleGrid[0].size() - 1] == 1) {
                return 0;
            }
            
        // dp数组含义，到达(i, j)共有多少条路径
        vector<vector<int>> dp(obstacleGrid.size(), vector<int> (obstacleGrid[0].size(), 0));
        // 对第一列进行初始化
        for (int i = 0; i < obstacleGrid.size() && obstacleGrid[i][0] == 0;
             i++) {
                dp[i][0] = 1;
             }
        // 对第一行进行初始化
        for (int j = 0; j < obstacleGrid[0].size() && obstacleGrid[0][j] == 0;
             j++) {
            dp[0][j] = 1;
        }

        // 进行递推公式迭代
        for (int i = 1; i < obstacleGrid.size(); i++) {
            for (int j = 1; j < obstacleGrid[0].size(); j++) {
                // 判断前方是否存在障碍物
                if (obstacleGrid[i][j] == 1) continue; // dp默认值为0
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[obstacleGrid.size() - 1][obstacleGrid[0].size() - 1];
    }
};
```

## 整数拆分

给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。

### 整数拆分思路

- dp[i] 表示将n拆分成至少i个正整数的最大乘积
- 递推公式，由于dp[i]代表着拆分为至少2个正整数的最大值，所以需要判断两个还是多个最佳
- 特殊值处理，n=1时，最大乘积为1
- $max(j * dp[i - j], j * (i -j))$

```cpp
class Solution {
public:
    int integerBreak(int n) {
        if (n == 2) return 1;
        // 确定dp数组的含义，将i拆分所得的最大值
        vector<int> dp(n + 1, 0);
        // 初始化dp数组
        dp[0] = 0;
        dp[1] = 0;
        dp[2] = 1;
        for (int i = 3; i <= n; i++) {
            for (int j = 1; j < i; j++) {
                dp[i] = max(max(j * (i - j), j * dp[i - j]), 
                            dp[i]); // 在两个数与三个数之间取最大值
            }
        }
        return dp[n];
    }
};
```

## 不同的二叉搜索树

给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？

### 不同的二叉搜索树思路

- dp[i] 表示以i个节点组成的二叉搜索树的个数
- dp[i] 可以依次表示为左边共有dp[j - 1] 右边共有[i - j]

```cpp
class Solution {
public:
    int numTrees(int n) {
        // dp数组含义，整数n下的二叉搜索树种类
        vector<int> dp(n + 1);
        // 初始化dp数组
        dp[0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= i; j++) {
                dp[i] += dp[j - 1] * dp[i - j];
            } 
        }
        return dp[n];
    }
};
```

## 背包问题

小明是一位科学家，他需要参加一场重要的国际科学大会，以展示自己的最新研究成果。他需要带一些研究材料，但是他的行李箱空间有限。这些研究材料包括实验设备、文献资料和实验样本等等，它们各自占据不同的空间，并且具有不同的价值。 

小明的行李空间为 N，问小明应该如何抉择，才能携带最大价值的研究材料，每种研究材料只能选择一次，并且只有选与不选两种选择，不能进行切割。

## 遍历顺序

根据状态转移方程确定遍历顺序，二维的先遍历物品还是背包是可以互换的，但三维的不行，根据状态转移方程可知。


### 01背包问题解题思路

- n种物品，每种只有一个
- dp[i][j] 表示0，i的物品任取放容量为j的背包（已经存在的物品重量）里所能达到的最大价值
- dp[i - 1][j - weight[i]]  + value[i](放物品i)
- dp[i - 1][j] 不放物品i

## 分割等和子集

给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

注意: 每个数组中的元素不会超过 100 数组的大小不会超过 200

### 分割等和子集思路

- 转化为01背包问题，物品的价值与重量等值，若dp[j] == j,则说明发现了一个组合可以让他们相等
- 如果总和除以2，有余数，则说明不可能
- 目标是让背包装满的情况下，其价值等于容量

```cpp
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0, target = 0;
        for (int i = 0; i < nums.size(); i++) sum += nums[i];
        if (sum % 2 != 0) return false;
        target = sum / 2;
        vector<int> dp(target + 1, 0);
        // 先遍历物品后遍历背包，防止滚动数组对dp[j]进行覆盖
        for (int i = 0; i < nums.size(); i++) {
            for (int j = target; j >= nums[i]; j--) {
                // 更新dp值,是否放nums[i]
                dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);
            }
        }

        if (dp[target] == target) return true;
        return false;
    }
};
```

## 最后一块石头的重量II有一堆石头，每块石头的重量都是正整数。

每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：

如果 x == y，那么两块石头都会被完全粉碎；

如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。

最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回 0。

### 最后一块石头的重量II思路

- 与上一题相似，将一堆石头尽可能地分成两堆，然后sum - 2 * max()

```cpp
class Solution {
public:
    int lastStoneWeightII(vector<int>& stones) {
        int sum = 0, target = 0;
        for (int i = 0; i < stones.size(); i++) sum += stones[i];
        target = sum / 2;
        // 定义dp数组
        vector<int> dp(target + 1, 0);
        // 遍历更新dp数组
        for (int i = 0; i < stones.size(); i++) {
            for (int j = target; j >= stones[i]; j--) {
                dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);
            }
        }
        // 返回差值
        return sum - 2 * dp[target];
    }
};
```

## 目标和

给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。

返回可以使最终数组和为目标数 S 的所有添加符号的方法数。

### 目标和思路

- 根据公式转换，将组合问题调整到背包问题当中
- 根据01背包问题，将物品填入到背包中获取left的最大数目

```cpp
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        int sum = 0;
        for (int i = 0; i < nums.size(); i++) sum += nums[i];
        if ((target + sum) % 2 == 1) return 0;
        if (abs(target) > sum) return 0;

        int left = (target + sum) / 2;
        // 创建dp数组
        // 当i = 0时，dp[0] = 0；表征未加入元素时的方法共有一种
        vector<int> dp(left + 1, 0);
        dp[0] = 1;
        // 判断装满left的背包的数目
        for (int i = 0; i < nums.size(); i++) {
            // 倒序，因为i是01背包，每一个物品只能放一个
            for (int j = left; j >= nums[i]; j--) {
                dp[j] += dp[j - nums[i]]; 
                // 放背包里面的物品，已经有了nums[i]之后还有几种方法可以凑成j - nums[i]
            }
        }
        return dp[left];
    }
};
```

## 一和零

给你一个二进制字符串数组 strs 和两个整数 m 和 n 。

请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。

如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。

### 一和零思路

- dp扩展为二维，i个0容量与j个1容量下最多能容纳多少个字符串
- 递推公式，dp[i][j] = dp[i - string[0][i]][j - string[1][i]] + 1 与不加这个字符串的最大值(当前字符串包含1个1)

```cpp
class Solution {
public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        // 创建dp数组（二维，第一维表示0的容量，第二维表示1的容量）
        vector<vector<int>> dp(m + 1, vector<int> (n + 1, 0));
        // 遍历获得每一个字符串的0，1个数
        for (string s : strs) {
            int x = 0, y = 0;
            for (char c : s) {
                if (c == '0') {
                    x++;
                } else {
                    y++;
                }
            }
            // 遍历背包
            for (int i = m; i >= x; i--) {
                for (int j = n; j >= y; j--) {
                    dp[i][j] = max(dp[i - x][j - y] + 1, dp[i][j]);
                }
            }
        }
        return dp[m][n];
    }
};
```

## 完全背包理论基础

有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品都有无限个（也就是可以放入背包多次），求解将哪些物品装入背包里物品价值总和最大。

完全背包和01背包问题唯一不同的地方就是，每种物品有无限件

## 零钱兑换II

给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。

### 零钱兑换Ⅱ

- 确定dp数组含义，dp[i]表示凑够金额i的组合种类数
- 遍历顺序--由于一个物品可以多次放入
- 递推公式--当背包里面已经有coins[i]时，还需要j - coins[i]的组合数

### 评论解答

关于组合和排列的问题还是有些不解。以下仅为自己的理解：先遍历物品后遍历背包是这样，比如，外层循环固定coins【1】，在内层循环遍历背包时，随着背包不断增加，coins【1】可以重复被添加进来，而由于外层循环固定了，因此coins【2】只能在下一次外层循环添加进不同大小的背包中，这么看的话，coins【i+1】只能在coins【i】之后了；如果先遍历背包后遍历物品，那么外层循环先固定背包大小j，然后在大小为j的背包中循环遍历添加物品，然后在下次外层循环背包大小变为j+1，此时仍要执行内层循环遍历添加物品，也就会出现在上一轮外层循环中添加coins【2】的基础上还能再添加coins【1】的情况，那么就有了coins【1】在coins【2】之后的情况了。

```cpp
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        // 初始化dp数组
        vector<int> dp(amount + 1, 0);
        // 当amount = 0时，共有一种组合方式
        dp[0] = 1;
        // 更新dp数组
        for (int i = 0; i < coins.size(); i++) {
            // 先遍历物品，再遍历背包
            for (int j = coins[i]; j <= amount; j++) {
                if (dp[j] < INT_MAX - dp[j - coins[i]]) {
                    dp[j] += dp[j - coins[i]];
                }  
            }
        }
        return dp[amount];
    }
};
```