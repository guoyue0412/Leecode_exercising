# 回溯算法

回溯与递归相辅相成

## 模板

void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}

## 组合

给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。

示例: 输入: n = 4, k = 2 输出: [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ]

## 组合思路

组合是无序的
递归三步法--递归函数参数与返回值， 确定终止条件， 单层递归逻辑

    ```cpp
    class Solution {
    public:
        // 定义全局变量，收集路径以及结果集合
        vector<int> path;
        vector<vector<int>> result;
        void backtracking(int n, int k, int starIndex) {
            if (path.size() == k) {
                // 达到终止条件，收集结果
                result.push_back(path);
                return;
            }
            // 未达到条件，则向下一层递归
            for (int i = starIndex; i <= n; i++) {
                path.push_back(i);
                backtracking(n, k, i + 1);
                // 向上一层迭代，并回溯
                path.pop_back();
            }
        }
        vector<vector<int>> combine(int n, int k) {
            result.clear(); // 结果重置
            path.clear(); // 路径重置
            backtracking(n, k, 1);
            return result;
        }
    };
    ```

优化将for语句的终止条件进行改变，因为路径收集不可能达到k所需的元素个数，因此多余的遍历变得没有意义**n - (k - path.size()) + 1**

## 组合总和III

找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。

说明：

所有数字都是正整数。
解集不能包含重复的组合。
示例 1: 输入: k = 3, n = 7 输出: [[1,2,4]]

示例 2: 输入: k = 3, n = 9 输出: [[1,2,6], [1,3,5], [2,3,4]]

### 组合总和Ⅲ思路

和组合的思路类似，只是多了一个限制条件，即组合中不能有重复的数字。因此将终止条件多加入一个即可
同时剪枝也有更多的优化，首先for的终止条件，其次若当前值已经大于target了，则不用继续遍历，因为后面的组合都不可能大于target了。（判断当前的值是否大于target）,因为是递增的序列，若大于target/k，则后面的组合都不可能大于target了。

    ```cpp
        class Solution {
            public:
            vector<vector<int>> result;
            vector<int> path;
            void backsteping(int startIndex,int k,int n,int sum) {
                if (sum > n) return;
                if (path.size() == k ) {
                    if (sum == n) {
                        result.push_back(path);
                    }
                    return;
                }
                for (int i = startIndex;i <= 9 - (k - path.size()) + 1;i++) {
                    sum += i;
                    path.push_back(i);
                    backsteping(i + 1,k,n,sum);
                    sum -= i; // 回溯过程
                    path.pop_back();

                }
            }
            vector<vector<int>> combinationSum3(int k, int n) {
                backsteping(1, k, n, 0);
                return result;
            }
        };
    ```

## 组合总和

给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的数字可以无限制重复被选取。

说明：

所有数字（包括 target）都是正整数。
解集不能包含重复的组合。

### 组合总和思路

- 无返回值，参数为candidatess和target,index,sum
- 终止条件：sum==target/sum > target
- 处理逻辑: 遍历candidates，在同一层中，变换index，防止出现不同组合，相同元素的情况
  - 剪枝操作：将数组进行排序，对于已经大于的结果，进行去除，即更改for的终止条件

```cpp
class Solution {
public:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int>& candidates,int target,int sum,int startIndex) {
        // 大于目标值，返回
        if (sum > target) {
            return;
        }
        // 等于目标值，添加路径到结果集合
        if (sum == target) {
            result.push_back(path);
            return;
        }
        // 小于目标值，开始层序递归
        for (int i = startIndex;i < candidates.size();i++) {
            path.push_back(candidates[i]);
            sum += candidates[i];
            backtracking(candidates, target, sum, i); // 因为允许重复的元素出现，所以从i开始
            sum -= candidates[i];// 回溯处理
            path.pop_back();
        }
    }
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        result.clear();
        path.clear();
        backtracking(candidates,target, 0, 0);
        return result;
    }
};
```

## 组合总和II

给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的每个数字在每个组合中只能使用一次。

说明： 所有数字（包括目标数）都是正整数。解集不能包含重复的组合。

### 组合总和II思路

- 无返回值，参数为candidatess和target,index,sum，与组合总和不同的是，递归传递的参数为i+1,因为不包括重复元素
- 重点：该数组中有重复元素
- 定义一个状态变量，当该元素被使用时，将其设置为true ，防止重复使用
- 层序不应出现重复的元素，这会导致组合问题出现顺序不同但元素相同的问题
- 树序可以出现重复的元素，因为这两个元素虽然相同，但是在树中是不同的位置，因此可以出现不同的组合

```cpp
class Solution {
public:
    vector<vector<int>> result;
    vector<int> path;
    void backtracing(vector<int>& candidates,int target,int sum,int startIndex,vector<bool>& used) {
        // 等于目标值采集结果
        if ( sum == target) {
                result.push_back(path);
                return;
        }
         // 大于目标值，结束递归
        for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++) {
            // 进行去重操作，首先传入的数组为排序数组，因此相邻的元素是大于等于的关系
            // 若used[i] == false 意味着，仍然进行着层序的遍历，若为true，意味着下一层的递归，这是可以允许的
            if (i > 0 && candidates[i] == candidates[i - 1] && used[i - 1] == false) {
                continue;
            }
            path.push_back(candidates[i]);
            sum += candidates[i];
            used[i] = true;
            backtracing(candidates,target,sum,i + 1,used);
            // 回溯过程
            path.pop_back();
            sum -= candidates[i];
            used[i] = false;
        }
    }   
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        vector<bool> used(candidates.size(),false);
        path.clear();
        result.clear();
        // 根据算法思想，要对传入的数据进行排序
        sort(candidates.begin(),candidates.end());
        backtracing(candidates,target,0,0,used);
        return result;
    }
};
```

## 分割回文串

给你一个字符串 s，请你将 s 分割成一些 子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。

 

示例 1：

输入：s = "aab"
输出：[["a","a","b"],["aa","b"]]
示例 2：

输入：s = "a"
输出：[["a"]]

### 分割回文串思路

- 采取切割问题，将字符串用隔板隔开操作
- 当新切割的子串满足回文串要求的时候，将其加入路径集，若不满足，则不向下递归
  
```cpp
  class Solution {
        public:
            vector<vector<string>> result;
            vector<string> path;
            bool isPlingdrome(const string& s,int startIndex,int endIndex) {
                // 双指针判断回文子串
                for (int i = startIndex,j = endIndex;i < j; i++,j--) {
                    if (s[i] != s[j]) {
                        return false;
                    }
                }
                return true;
            }
            void backtracking(const string& s,int startIndex) {
                if (startIndex >= s.size()) {
                    // 切割到末尾，收获结果
                    result.push_back(path);
                    return;
                }
                for (int i = startIndex; i < s.size(); i++) {
                    if (isPlingdrome(s,startIndex,i)) {
                        string str = s.substr(startIndex,i - startIndex + 1);
                        path.push_back(str);
                    } else {
                        continue;
                    }
                    // 回溯过程
                    backtracking(s,i + 1);
                    path.pop_back();
                }
            }
            vector<vector<string>> partition(string s) {
                path.clear();
                result.clear();
                backtracking(s,0);
                return result;
            }
        };
```

## 复原IP地址

给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。

有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。

例如："0.1.2.201" 和 "192.168.1.1" 是 有效的 IP 地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 无效的 IP 地址。

### 复原IP地址思路

- 共四个整数，所以总共切三刀
- 判断刀数，若刀数大于3则收集结果集(将判断是否是合法的IP放到最下层的判断中)

```cpp
class Solution {
public:
    vector<string> result;
    bool isvaild(const string& s,int startIndex,int endIndex) {
        // 若区间不合理，返回false
        if (startIndex > endIndex) {
            return false;
        }
        // 若第一个IP地址，开始为零，返回false
        if (s[startIndex] == '0' && startIndex != endIndex) {
            return false;
        }
        //  判断ip地址是否大于255
        int num = 0;
        for (int i = startIndex;i <= endIndex;i++) {
            // 判断字符是否合规
            if (s[i] < '0' || s[i] > '9') {
                return false;
            }
            // 从高位获取数字，并逐步左移（十进制）
            num = num * 10 + (s[i] - '0');
            if (num > 255) {
                return false;
            }
        }
        return true;
    }
    void backtracking(string& s,int startIndex,int pointNum) {
        if (pointNum == 3) {
            // 切割三刀后，添加到结果集（由于最后一位数字不跟.因此将最后一位的判断加入到递归终止的处理当中）
            if (isvaild(s,startIndex,s.size() - 1)) {
                result.push_back(s);
            }
            return;
        }
        for (int i = startIndex;i < s.size();i++) {
            if (isvaild(s,startIndex,i)) {
                // 若为正确的ip地址，则将该数字加入到path中，并在后面加入.
                s.insert(s.begin() + i + 1,'.');
                pointNum++;
                backtracking(s,i + 2,pointNum);
                pointNum--;
                s.erase(s.begin() + i + 1);
            } else {
                break;
            }
        }
    }
    vector<string> restoreIpAddresses(string s) {
        result.clear();
        if (s.size() < 4 || s.size() > 12) return result;
        backtracking(s,0,0);
        return result;
    }
};
```

## 子集

给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。

说明：解集不能包含重复的子集。

示例: 输入: nums = [1,2,3] 输出: [ [3],   [1],   [2],   [1,2,3],   [1,3],   [2,3],   [1,2],   [] ]

### 子集思路

- 采取回溯法，将数组中的元素作为起点，递归地枚举所有可能的子集
- 遍历到起始位置等于nums.size()时
- 收集结果--将当前路径加入到结果集

```cpp
class Solution {
public:
    vector<int> path;
    vector<vector<int>> result;
    void backtracking (vector<int>& nums,int startIndex) {
        // 收集所有的结果集
        result.push_back(path);

        if (startIndex >= nums.size()) {
            // 当起始位置大于num.size(),终止递归
            return;
        }

        for (int i = startIndex;i < nums.size();i++) {
            path.push_back(nums[i]);
            backtracking(nums,i + 1);
            // 回溯过程
            path.pop_back();
        }
    }
    vector<vector<int>> subsets(vector<int>& nums) {
        path.clear();
        result.clear();
        backtracking(nums,0);
        return result;
    }
};
```

## 子集Ⅱ

给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。

说明：解集不能包含重复的子集。

示例:

输入: [1,2,2]
输出: [ [2], [1], [1,2,2], [2,2], [1,2], [] ]

### 子集Ⅱ思路

- 使用used[i]数组，确定该元素是否被使用
- 同时确定是数层还是层序，判断同一层内不准使用相同元素，数层可以使用相同元素

```cpp
class Solution {
public:
    vector<int> path;
    vector<vector<int>> result;
    
    void backtracking(vector<int>& nums,int startIndex,vector<bool>& used) {
        // 收获结果
        result.push_back(path);
        if (startIndex >= nums.size()) {
            // 遍历到最后一位，结束递归
            return;
        }
        for (int i = startIndex;i < nums.size();i++) {
            if (i > 0 && nums[i] == nums[i - 1] &&  used[i - 1] == false) {
                // 若为同一层，且前后元素相同，则不进行递归
                continue;
            }
            // 向下层遍历，允许出现重复元素
            path.push_back(nums[i]);
            used[i] = true;
            backtracking(nums,i + 1,used);
            // 回溯过程
            used[i] = false;
            path.pop_back();
        }
    }
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        path.clear();
        result.clear();
        vector<bool> used(nums.size(), false);
        sort(nums.begin(),nums.end());
        backtracking(nums,0,used);
        return result;
    }
};
```

## 递增子序列

给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。

示例:

输入: [4, 6, 7, 7]
输出: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]
说明:

给定数组的长度不会超过15。
数组中的整数范围是 [-100,100]。
给定数组中可能包含重复数字，相等的数字应该被视为递增的一种情况。

### 递增子序列思路

- 与子集不同的是，子集中元素的顺序不重要，而递增子序列中元素的顺序是重要的，因此无法对给出的数组进行排序操作

```cpp
class Solution {
public:
    vector<int> path;
    vector<vector<int>> result;
    void backTracing(vector<int>& nums, int startIndex) {
        // 收获结果
        if (path.size() > 1) {
            result.push_back(path);
        }
        // 达到递归条件，向上层返回
        if (startIndex > nums.size()) {
            return;
        }
        // 创建哈希表，在同一层上进行去重
        unordered_set<int> uset;
        for (int i = startIndex; i < nums.size(); i++) {
            // 满足递增数列并且未有重复元素
            if (!path.empty() && nums[i] < path.back() 
            || uset.find(nums[i]) != uset.end()) {
                continue;
            }
            // 向下层递归
            path.push_back(nums[i]);
            uset.insert(nums[i]);
            backTracing(nums, i + 1);
            // 回溯过程
            path.pop_back();
            // 每一层的uset都是重置的，因为uset无需重置
        }
        
    }
    vector<vector<int>> findSubsequences(vector<int>& nums) {
        result.clear();
        path.clear();
        backTracing(nums, 0);
        return result;
    }
};
```

## 全排列

给定一个 没有重复 数字的序列，返回其所有可能的全排列。

示例:

输入: [1,2,3]
输出: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ]

### 全排列思路

- 全排列是组合问题，也就是顺序不同也是一个path
- 数层无需去重，而数枝需要去重，因为数组的元素都是独一无二的

```cpp
class Solution {
public:
    vector<vector<int>> result;
    vector<int> path;
    void backTracing(vector<int>& nums, vector<bool> used) {
        // 达到终止条件，停止递归
        if (path.size() == nums.size()) {
            result.push_back(path);
            return;
        }
        // 进行层序遍历
        for (int i = 0; i < nums.size(); i++) {
            if (used[i] != false) continue; // 已经使用过，就跳过
            path.push_back(nums[i]);
            used[i] = true;
            // 进入下一层递归
            backTracing(nums, used);
            // 回溯
            path.pop_back();
            used[i] = false;

        }
    }
    vector<vector<int>> permute(vector<int>& nums) {
        result.clear();
        path.clear();
        vector<bool> used(nums.size(), false);
        backTracing(nums, used);
        return result;
    }
};
```

## 全排列 II

给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。

示例 1：

输入：nums = [1,1,2]
输出： [[1,1,2], [1,2,1], [2,1,1]]
示例 2：

输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
提示：

1 <= nums.length <= 8
-10 <= nums[i] <= 10

### 全排列 II思路

- 与全排列不同的是，全排列II中，同一层的元素不能重复（这样会导致树枝出现重复的排列组合）
- 因此在全排列的基础上，要加一个新的判断，防止出现数层临近元素的相似(给出的数组为升序数组)

```cpp
class Solution {
public:
    vector<int> path;
    vector<vector<int>> result;
    void backTracing(vector<int>& nums, vector<bool>& used) {
        // 达到数组大小，收获结果
        if (path.size() == nums.size()) {
            result.push_back(path);
            return;
        }
        // 进入遍历，数层
        for (int i = 0; i < nums.size(); i++) {
            if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) {
                // 说明在层序中出现了重复元素，跳过
                continue;
            }
            if (used[i] == true) {
                continue;
            }
            path.push_back(nums[i]);
            used[i] = true;
            // 向下遍历
            backTracing(nums, used);
            // 回溯
            path.pop_back();
            used[i] = false;
        }

    }
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        result.clear();
        path.clear();
        vector<bool> used(nums.size(), false);
        sort(nums.begin(), nums.end());
        backTracing(nums, used);
        return result;
    }
};
```

## N皇后

n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。

每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位

### N皇后思路

- 采用回溯法，将棋盘的每一行作为起点，递归地枚举所有可能的皇后位置
- 遍历到起始位置等于n时
- 收集结果--将当前路径加入到结果集
- 自定义一个判断是否合规的函数，从列遍历，45与135度方向判断是否出现'Q

```cpp
class Solution {
public:
    vector<vector<string>> result;
    bool isValid(vector<string>& path, int row, int col, int n) {
    // 检查列
    for (int i = 0; i < row; i++) {
        if (path[i][col] == 'Q') return false;
    }
    // 检查45度方向
    for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
        if (path[i][j] == 'Q') {
            return false;
        }
    }
    // 检查135度方向
    for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {
        if (path[i][j] == 'Q') {
            return false;
        }
    }
    return true;
    }
    
    
    void backTracing(vector<string>& path, int n, int row) {
        // 达到收获条件
        if (row == n) {
            result.push_back(path);
            return;
        }
        for (int i = 0; i < n; i++) {
            if (isValid(path, row, i, n) == true) {
                path[row][i] = 'Q';
                backTracing(path, n, row + 1);
                // 回溯过程
                path[row][i] = '.';
            }
        }
    }
    vector<vector<string>> solveNQueens(int n) {
        vector<string> path(n, string(n, '.'));
        result.clear();
        backTracing(path, n, 0);
        return result;
    }
};
```

## 重新安排行程

给定一个机票的字符串二维数组 [from, to]，子数组中的两个成员分别表示飞机出发和降落的机场地点，对该行程进行重新规划排序。所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。

提示：

如果存在多种有效的行程，请你按字符自然排序返回最小的行程组合。例如，行程 ["JFK", "LGA"] 与 ["JFK", "LGB"] 相比就更小，排序更靠前
所有的机场都用三个大写字母表示（机场代码）。
假定所有机票至少存在一种合理的行程。
所有的机票必须都用一次 且 只能用一次。
示例 1：

输入：[["MUC", "LHR"], ["JFK", "MUC"], ["SFO", "SJC"], ["LHR", "SFO"]]
输出：["JFK", "MUC", "LHR", "SFO", "SJC"]
示例 2：

输入：[["JFK","SFO"],["JFK","ATL"],["SFO","ATL"],["ATL","JFK"],["ATL","SFO"]]
输出：["JFK","ATL","JFK","SFO","ATL","SFO"]
解释：另一种有效的行程是 ["JFK","SFO","ATL","JFK","ATL","SFO"]。但是它自然排序更大更靠后。

### 重新安排行程思路

unordered_map<string, multiset> targets：unordered_map<出发机场, 到达机场的集合> targets

unordered_map<string, map<string, int>> targets：unordered_map<出发机场, map<到达机场, 航班次数>> targets

这两个结构，我选择了后者，因为如果使用unordered_map<string, multiset<string>> targets 遍历multiset的时候，不能删除元素，一旦删除元素，迭代器就失效了。
既要找到一个对数据进行排序的容器，而且还要容易增删元素，迭代器还不能失效

1. 遍历所有机票，将出发机场和到达机场分别加入到两个结构中
2. 遍历所有机票，将航班次数加入到targets[出发机场][到达机场]中

```cpp
class Solution {
public:
    // unordered_map<出发机场, map<到达机场, 航班次数>> targets
    unordered_map<string, map<string, int>> targets;
    bool backTracking(int ticketNum, vector<string>& result) {
        if (result.size() == ticketNum + 1) {
            return true;
        }
        for (pair<const string, int>& target : targets[result[result.size() - 1]]) {
            if (target.second > 0 ) { // 记录到达机场是否飞过了
            result.push_back(target.first);
            target.second--;
            if (backTracking(ticketNum, result)) return true;
            result.pop_back();
            target.second++;
            }
        }
        return false;
    }
    vector<string> findItinerary(vector<vector<string>>& tickets) {
        targets.clear();
        for (const vector<string>& vec : tickets) {
            targets[vec[0]][vec[1]]++;
        }
        vector<string> result;
        result.push_back("JFK");
        backTracking(tickets.size(), result);
        return result;
    }
};
```