# 栈与队列

队列是先进先出，栈是先进后出（栈和队列是STL（C++标准库）里面的两个数据结构）

- 递归的实现是栈：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。
匹配是栈的强项（一对的匹配问题）

## 用栈实现队列

### 用栈实现队列思路

设置两个栈，入栈与出栈  
入栈时，直接入栈到栈1  
出栈时，如果栈2为空，则将栈1中的元素全部出栈到栈2，再从栈2中出栈  
push(x) -- 利用栈1进行入栈操作
pop() -- 利用栈2进行出栈操作，如果栈2为空，则将栈1中的元素全部出栈到栈2，再从栈2中出栈
peek() -- 返回队列首部的元素
empty() -- 判断队列是否为空

```cpp
class MyQueue {
public:
    stack<int> stIn;
    stack<int> stOut;
    MyQueue() {
        
    }
    
    void push(int x) {
        stIn.push(x);
    }
    
    int pop() {
        if (stOut.empty()) {
            while (!stIn.empty()){
                stOut.push(stIn.top());
                stIn.pop();
            }
        }
        int result = stOut.top();
        stOut.pop();
        return result;
    }
    
    int peek() {
        if (stOut.empty()) {
            while (!stIn.empty()){
                stOut.push(stIn.top());
                stIn.pop();
            }
        }
        int result = stOut.top();
        return result;
    }
    
    bool empty() {
        return stIn.empty() && stOut.empty();
    }
};
```

## 用队列实现栈

### 用队列实现栈思路

设一个队列，由于队列有头有尾，因此可以将队头的元素不断加入队尾中，所以设置一个size即可

```cpp
class MyStack {
public:
    queue<int> que;

    MyStack() {

    }

    void push(int x) {
        que.push(x);
    }

    int pop() {
        int size = que.size();
        size--;
        while (size--) { // 将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部
            que.push(que.front());
            que.pop();
        }
        int result = que.front(); // 此时弹出的元素顺序就是栈的顺序了
        que.pop();
        return result;
    }

    int top(){
        int size = que.size();
        size--;
        while (size--){
            // 将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部
            que.push(que.front());
            que.pop();
        }
        int result = que.front(); // 此时获得的元素就是栈顶的元素了
        que.push(que.front());    // 将获取完的元素也重新添加到队列尾部，保证数据结构没有变化
        que.pop();
        return result;
    }

    bool empty() {
        return que.empty();
    }
};
```

## 有效的括号

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。

### 有效括号思路

- 剪枝操作（如果size不被2整除，则肯定是不合法的 || 如果栈在过程中已经为空，并且当前字符不是左括号括号，则肯定是不合法的）
- 栈的应用（先进先出，满足括号的闭合原则）
- 如果是[{(,则加入)]}（这样便于进行定位，如果相同则pop）
- 最后的判断条件是st是否为空，若为空则说明括号匹配成功

```cpp  
class Solution {
public:
    bool isValid(string s) {
        if (s.size() % 2 != 0) return false;
        stack<char> st;
        for (int i = 0; i < s.size(); i++) {
            
            if (s[i] == '(') {
                st.push(')');
            } else if (s[i] == '['){
                st.push(']');
            } else if (s[i] == '{'){
                st.push('}');
            } else if  (st.empty() || st.top() != s[i]){
                return false;
                
            } else {
                st.pop();
            }
            
        }
        return st.empty();

        
    }
};
```

## 删除字符串中的所有相邻重复项

给定一个字符串，你需要去除字符串中相邻重复项，使得每个字符只出现一次。

### 删除字符串中的所有相邻重复项思路

- 栈的应用（先进先出，遇到字符与栈顶相同，则弹出；若栈为空或者字符与栈顶不相同，则push）
- 简便方法，由于栈的先进先出，返回字符串时，需要将栈中的元素倒序输出，所以可以利用字符串进行数据保存，然后返回字符串即可

```cpp
class Solution {
public:
    string removeDuplicates(string s) {
        string result;
        for (char c : s) {
            if (result.empty() || c != result.back()) {
                result.push_back(c);
            } else {
                result.pop_back();
            }
        }
        return result;
    }
};
```

## 逆波兰表达式求值

逆波兰表达式（RPN，Reverse Polish Notation）是一种后缀表达式，它是一种运算符优先级不确定的表达式。

### 逆波兰表达式求值思路

运用栈的特点（适合匹配）

```cpp
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        stack<int> st;
        for (int i = 0; i < tokens.size(); i++) {
            if (tokens[i] == "-" || tokens[i] == "+" || tokens[i] == "*" || tokens[i] == "/") {
                long long num1 = st.top();
                st.pop();
                long long num2 = st.top();
                st.pop();
                if (tokens[i] == "-") st.push( num2 - num1);
                else if (tokens[i] == "+") st.push(num1 + num2);
                else if (tokens[i] == "*") st.push(num1 * num2);
                else st.push(num2 / num1);
            } else {
                st.push(stoll(tokens[i]));
            }
        }
        return st.top();
    }
};
```

## 滑动窗口最大值

### 滑动窗口最大值思路

利用队列（双向队列）—— 队列的头部始终指向当前窗口的最大值，队列的尾部始终指向当前窗口的最小值
pop() -- 当弹出的为窗口最大值并且队列不为空时，弹出

- (如何判断该队列要pop，取决于队尾的元素是否等于最大值，若等于则说明该最大值已经不在视野中了，利用nums[i - k] 来保证数值被正确弹出，但只有当视野中最大值被弹出时，才会生效）  

push() -- 保证push的元素均比头部的元素小，满足单调队列
getMax（） -- 返回队列头部的元素

```cpp
class Solution {
private:
    class MyQueue { //单调队列（从大到小）
    public:
        deque<int> que; // 使用deque来实现单调队列
        // 每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。
        // 同时pop之前判断队列当前是否为空。
        void pop(int value) {
            if (!que.empty() && value == que.front()) {
                que.pop_front();
            }
        }
        // 如果push的数值大于入口元素的数值，那么就将队列后端的数值弹出，直到push的数值小于等于队列入口元素的数值为止。
        // 这样就保持了队列里的数值是单调从大到小的了。
        void push(int value) {
            while (!que.empty() && value > que.back()) {
                que.pop_back();
            }
            que.push_back(value);

        }
        // 查询当前队列里的最大值 直接返回队列前端也就是front就可以了。
        int front() {
            return que.front();
        }
    };
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        MyQueue que;
        vector<int> result;
        for (int i = 0; i < k; i++) { // 先将前k的元素放进队列
            que.push(nums[i]);
        }
        result.push_back(que.front()); // result 记录前k的元素的最大值
        for (int i = k; i < nums.size(); i++) {
            que.pop(nums[i - k]); // 滑动窗口移除最前面元素
            que.push(nums[i]); // 滑动窗口前加入最后面的元素
            result.push_back(que.front()); // 记录对应的最大值
        }
        return result;
    }
};
```

## 前 K 个高频元素

给定一个非空的整数数组，返回其中出现频率前 k 高的元素。

### 前 K 个高频元素思路

- 哈希表的应用（记录每个元素出现的次数）
- 优先队列的应用（优先队列默认是小根堆，因此可以用大根堆来实现优先队列）队列的顶部总是储存最大/最小元素，pop/top一致
- 堆排序的应用（堆排序的时间复杂度为O(nlogn)，因此可以用堆排序来实现）

### 小顶堆，大顶堆的使用方法

```cpp
priority_queue<pair<int, int>, vector<pair<int, int>>,mycomparison> pri_que;
```

第一个元素，指定小顶堆中储存的数据格式，第二个指定用于小顶堆实现的functor，第三个指定顶堆排序的方法（创建一个类，用operator()重载，返回true则表示lhs小于rhs，false则表示lhs大于rhs）

### 一种对于unordered_map的循环的实现

```cpp
for (unordered_map<int, int>::iterator it = hashTable.begin(); it != hashTable.end(); it++)
```

```cpp
class Solution {
public:
    // 小顶推
    class mycomparison {
        public:
            bool operator()(const pair<int,int>& lhs,const pair<int,int>& rhs) {
                return lhs.second > rhs.second;
            }
    };
    vector<int> topKFrequent(vector<int>& nums, int k) {
        // 统计每一个元素出现的频率
        unordered_map<int,int> hashTable;
        for (int i = 0; i < nums.size(); i++) {
            hashTable[nums[i]]++;
        }
        // 对每个元素出现频率进行排序
        // 定义一个小顶堆
        priority_queue<pair<int, int>, vector<pair<int, int>>,mycomparison> pri_que;

        // 将小顶堆的元素个数进行限制
        for (unordered_map<int, int>::iterator it = hashTable.begin(); it != hashTable.end(); it++) {
            // 用固定大小的小顶堆
            pri_que.push(*it);
            if (pri_que.size() > k) {
                pri_que.pop();
            }
        } 
        // 储存前k个高频元素
        vector<int> result(k);
        for (int i = k - 1; i >= 0; i--) {
            result[i] = pri_que.top().first;
            pri_que.pop();
        }
        return result;
    }
};
```
