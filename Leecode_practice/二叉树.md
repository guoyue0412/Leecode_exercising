# 二叉树

## 二叉树的种类

- 完全二叉树
除最后一层外，都是满节点，最后一层从左到右连续。
- 二叉树搜索树
左子树节点的值小于根节点的值，右子树节点的值大于根节点的值。
- 平衡二叉搜索树
左右子树高度差不超过1。

## 二叉树的存储方式

二叉树可以链式存储，也可以顺序存储

## 二叉树的遍历

### 深度优先搜索（一般采取递推方式）

- 前序遍历：根节点->左子树->右子树（中左右）
- 中序遍历：左子树->根节点->右子树 （左中右）
- 后序遍历：左子树->右子树->根节点（左右中）

### 广度优先搜索（一般采用队列，迭代法）

- 层序遍历：按层次遍历树的节点。

## 二叉树的基本操作

- 建立二叉树

```cpp
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
```

## 二叉树的递归遍历逻辑

递归三要素

- 确定递归函数的参数和返回值
- 确定终止条件
- 确定单层递归的逻辑  

### 前序遍历

递推函数的参数：根节点，返回值： void
终止条件：返回节点为空
单层递归逻辑：

- 访问根节点
- 递归左子树
- 递归右子树

#### 非递归法实现

用栈去模拟这个过程，由于前序过程，处理节点与放入节点都是一个
同时由于栈的先进后出的特性，因此先处理根节点，再处理右子树，最后处理左子树。

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        stack<TreeNode*> st; // 创建一个栈，用于存放节点指针
        vector<int> result; // 创建一个容器，用于存放int的整数
        st.push(root); // 将节点指针放入栈中，但注意节点指针对应的节点可能为空
        while (!st.empty()) { // 若为空，则continue， 不为空则将结果放入到result中
            TreeNode* node = st.top();
            st.pop();
            if (node == nullptr) {
                continue;
            } else {
                result.push_back(node->val);
            }
            // 由于是栈，所以先放右再放左（这样弹出的时候，可以保证先左再右）
            st.push(node->right);
            st.push(node->left);
        }
        return result;
    }
};
```

### 后序遍历

递推函数的参数：根节点，返回值： void
终止条件：返回节点为空
单层递归逻辑：

- 递归左子树
- 递归右子树
- 访问根节点

#### 非递归法实现——后序

用栈去模拟这个过程，由于后序过程与前序是颠倒关系，因此先实现中右左的遍历，最后对结果进行倒叙输出即可

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        // 由于前序跟后序是颠倒顺序，所以创建中右左，在对vecto<int>进行倒序
        stack<TreeNode*> st; // 创建一个栈，用于存放节点指针
        vector<int> result; // 创建一个容器，用于存放int的整数
        st.push(root); // 将节点指针放入栈中，但注意节点指针对应的节点可能为空
        while (!st.empty()) { // 若为空，则continue， 不为空则将结果放入到result中
            TreeNode* node = st.top();
            st.pop();
            if (node == nullptr) {
                continue;
            } else {
                result.push_back(node->val);
            }
            // 由于是栈，所以先放左再放右（这样弹出的时候，可以保证先右再左）
            st.push(node->left);
            st.push(node->right);
        }
        // 双指针进行颠倒
        int tmp = 0;
        for (int first = 0, last = result.size() - 1; first < result.size() / 2;
         first++, last--) {
            tmp = result[last];
            result[last] = result[first];
            result[first] = tmp;
         }
        return result;
    }
};
```

### 中序遍历

递推函数的参数：根节点，返回值： void
终止条件：返回节点为空
单层递归逻辑：

- 递归左子树
- 访问根节点
- 递归右子树

#### 非递归法实现——中序

由于中序遍历，第一个加入的节点是根节点，而处理的节点确实左子树，无法对应（后序可以通过倒叙来改变）
因此，需要建立一个栈，先将根节点入栈，然后基于二叉树的特性进行遍历输出

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        TreeNode* node = root;
        stack<TreeNode*> st;
        vector<int> result;
        while (!st.empty() || node != nullptr) {
            // 若st没有元素，同时node为空，则说明已经完成遍历
            if (node != nullptr) {
                // node不为空，说明未到底层，继续遍历
                st.push(node);
                node = node->left;
            } else {
                // node 为空说明到左子树，则取出元素并按照中序的逻辑，依次将中右加入
                node = st.top();
                st.pop();
                result.push_back(node->val); // 中
                node = node->right; // 右
            }
        }
        return result;
    }
};
```

### 层序遍历

递推函数的参数：根节点，返回值： void
终止条件：返回节点为空
单层递归逻辑：

- 建立一个队列，将根节点入队
- 设置一个size变量，记录每一层的节点数量
- 遍历size，确定哪些是这一层的节点，并以此将该节点的左右孩子放入队列中
- 若队列不为空，则重复上述步骤，直到队列为空
- 返回遍历结果
  
```cpp
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        vector<vector<int>> result;
        while (!que.empty()) {
            int size = que.size();
            vector<int> vec;
            // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                vec.push_back(node->val);
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            result.push_back(vec);
        }
        return result;
    }
};
```

## 层序遍历Ⅱ

### 层序遍历Ⅱ思路

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrderBottom(TreeNode* root) {
        // 创建一个队列，先进先出的特性
        queue<TreeNode*> que;
        // 创建一个二叉树节点指针，防止对原二叉树误操作
        TreeNode* cur = root;
        // 若不为空，则加入队列；为空则无需循环，直接返回空vector
        if (cur != nullptr) que.push(cur);
        vector<vector<int>> result;
        // 对每一层的值加入到ans中，并在pop的同时，将存在的左右节点依次加入队列中，直到que为空
        while (!que.empty()) {
            int size = que.size();
            vector<int> ans;
            for (int i = 0; i< size; i++) {
                TreeNode* node = que.front();
                ans.push_back(node->val);
                que.pop();
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            result.push_back(ans);
        }
        // 基于双指针方法，对result进行倒序
        reverse(result.begin(), result.end());
        return result;
    }
};
```

## 二叉树的右视图

### 二叉树的右视图思路

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        queue<TreeNode*> que;
        TreeNode* cur = root;
        if (cur != nullptr) que.push(cur);
        vector<int> result;
        while (!que.empty()) {
            int size = que.size();
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                // 如果是最后一个元素，则是这一层右视图中可以看到的元素
                if (i == size - 1) result.push_back(node->val);
                if (node->left != nullptr) que.push(node->left);
                if (node->right != nullptr) que.push(node->right);
            }
        }
        return result;
        
    }
};
```

## N叉树的层序遍历

### N叉树的层序遍历思路

```cpp
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
public:
    vector<vector<int>> levelOrder(Node* root) {
        queue<Node*> que;
        // 创建队列
        vector<vector<int>> result;
        // 创建一个节点指针，防止对原节点误操作
        Node* cur = root;
        // 若不为空，则加入队列，构成第一层
        if (cur != NULL) que.push(cur);
        while (!que.empty()) {
            // 确定本层的大小
            int size = que.size();
            vector<int> ans;
            for (int i = 0; i < size; i++) {
                // 循环将val加入ans中
                Node* node = que.front();
                ans.push_back(node->val);
                que.pop();
                // 将该层节点的子孩子依次加入到队列中
                vector<Node*> children = node->children;
                int list_size = children.size();
                for (int j = 0; j < list_size; j++) {
                    if(children[j] != NULL) que.push(children[j]);
                }
            }
            // 返回结果
            result.push_back(ans);
        }
        return result;

    }
};
```

## 填充每个节点的下一个右侧节点指针

### 填充每个节点的下一个右侧节点指针思路

```cpp
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;
    Node* next;

    Node() : val(0), left(NULL), right(NULL), next(NULL) {}

    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}

    Node(int _val, Node* _left, Node* _right, Node* _next)
        : val(_val), left(_left), right(_right), next(_next) {}
};
*/

class Solution {
public:
    Node* connect(Node* root) {
        queue<Node*> que;
        Node* cur = root;
        if (cur != NULL) que.push(cur);
        while (!que.empty()) {
            int size = que.size();
            for (int i = 0; i < size; i++) {
                Node* node = que.front();
                que.pop();
                if (node->left != NULL) que.push(node->left);
                if (node->right != NULL) que.push(node->right);
                // 如果不是该层最后一个，则将next指向右侧节点
                if (i != size - 1) {
                    node->next = que.front();
                }
            }
        }
        return root;
    }
};
```

## 二叉树的最小深度

### 二叉树的最小深度思路

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int minDepth(TreeNode* root) {
        if (root == nullptr) return 0;
        int depth = 0;
        TreeNode* cur = root;
        queue<TreeNode*> que;
        que.push(cur);
        while (!que.empty()) {
            // 每一次循环，相对于对每一层进行输出，depth加1
            depth++;
            int size = que.size();
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                if (node->left != nullptr) que.push(node->left);
                if (node->right != nullptr) que.push(node->right);
                // 若当前节点的左右子节点均为空，说明是最小深度，返回
                if (node->left == nullptr && node->right == nullptr) {
                    return depth;
                }
            }
        }
        return depth;
    }
};
```

## 翻转二叉树

### 翻转二叉树思路

- 确定遍历顺序是第一步--前序或后序
- 递归的三部曲
- 终止条件--当节点为空节点时，返回
- 递归逻辑
- 返回值树节点  

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    // 建立一个递归函数
    TreeNode* inverTraversal(TreeNode* cur) {
        if (cur == nullptr) return cur;
        swap(cur->left, cur->right); // 前序遍历（中左右）
        inverTraversal(cur->left); // 左子树
        inverTraversal(cur->right); // 右子树
        return cur;
    }
    TreeNode* invertTree(TreeNode* root) {
        inverTraversal(root);
        return root;
    }
};/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    // 建立一个递归函数
    TreeNode* inverTraversal(TreeNode* cur) {
        if (cur == nullptr) return cur;
        swap(cur->left, cur->right); // 前序遍历（中左右）
        inverTraversal(cur->left); // 左子树
        inverTraversal(cur->right); // 右子树
        return cur;
    }
    TreeNode* invertTree(TreeNode* root) {
        inverTraversal(root);
        return root;
    }
};
```

## 对称二叉树

### 对称二叉树思路

- 确定遍历顺序是第一步--后序（因为要对比两侧的节点是否相等，相等于先把左右处理之后再返回给中间节点信息）

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool compare(TreeNode* leftNode, TreeNode* rightNode) {
        // 排除空节点的情况
        if (leftNode == nullptr && rightNode != nullptr) return false;
        else if (leftNode != nullptr && rightNode == nullptr) return false;
        else if (leftNode == nullptr && rightNode == nullptr) return true;
        // 排除空节点后，再判断值是否相等
        else if (leftNode->val != rightNode->val) return false;
        
        // 还剩下左右节点均不为空，且值相等的情况
        bool outSide = compare(leftNode->left, rightNode->right);
        bool inSide = compare(leftNode->right, rightNode->left);
        return inSide && outSide;
    }
    bool isSymmetric(TreeNode* root) {
        if (root == nullptr) return true;
        bool result = compare(root->left, root->right);
        return result;
    }
};
```

## 相同的树

给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。
如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

### 相同的树思路

- 递归顺序--先序遍历
- 递归三部曲
- 空节点/两个值或者节点结构不同时，终止
- 递归逻辑--判断左右子树是否相同
- 返回值--布尔值

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool traversal(TreeNode* oneTree, TreeNode* twoTree) {
        if (oneTree == nullptr && twoTree != nullptr) return false;
        else if (oneTree != nullptr && twoTree == nullptr) return false;
        else if (oneTree == nullptr && twoTree == nullptr) return true;
        else if  (oneTree->val != twoTree->val) return false;
        bool left = traversal(oneTree->left, twoTree->left);
        bool right = traversal(oneTree->right, twoTree->right);
        return left && right;
    }
    bool isSameTree(TreeNode* p, TreeNode* q) {
        return traversal(p, q);
    }
};
```

## 另一棵树的子树

### 另一棵树的子树思路

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool isSameTree(TreeNode* oneTree, TreeNode* twoTree) {
        if (oneTree == nullptr && twoTree != nullptr) return false;
        else if (oneTree != nullptr && twoTree == nullptr) return false;
        else if (oneTree == nullptr && twoTree == nullptr) return true;
        else if  (oneTree->val != twoTree->val) return false;
        bool left = isSameTree(oneTree->left, twoTree->left);
        bool right = isSameTree(oneTree->right, twoTree->right);
        return left && right;
    }
    bool isSubtree(TreeNode* root, TreeNode* subRoot) {
        if (root == nullptr && subRoot != nullptr) return false;
        if (subRoot == nullptr) return true;
        return isSameTree(root, subRoot) ||
                isSubtree(root->left, subRoot) ||
                isSubtree(root->right, subRoot);
    }
};
```

## 二叉树的最大深度

### 二叉树的最大深度思路

- 确定遍历顺序（后序遍历）
- 递归的三部曲
- 终止条件--当节点为空节点时，返回
- 递归逻辑 -- 中间节点返回左右子树的最大深度并加一
- 传入/出参数--节点与深度

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int maxDepth(TreeNode* root) {
        // 若为空节点，则深度为0
        if (root == nullptr) return 0;
        // 往左子树遍历，并获得左子树的深度
        int left = maxDepth(root->left);
        // 往右子树遍历，并获得右子树的深度
        int right = maxDepth(root->right);
        // 返回左/右 子树的最大深度并加1
        return max(left, right) + 1;
    }
};
```

## 二叉树的最小深度—递归(最小深度定义)

给定一个二叉树，找出其最小深度。
最小深度是从根节点到最近叶子节点的最短路径上的节点数量。
说明: 叶子节点是指没有子节点的节点。

### 二叉树的最小深度-递归思路

- 确定遍历顺序（后序遍历）
- 递归的三部曲
- 终止条件--当节点为空节点时，返回
- 递归逻辑 -- 中间节点返回左右子树的最小深度并加一
- 传入/出参数--节点与深度

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int minDepth(TreeNode* root) {
        // 若为空节点，则深度为0
        if (root == nullptr) return 0;
        // 往左子树遍历，并获得左子树的深度
        int left = minDepth(root->left);
        // 往右子树遍历，并获得右子树的深度
        int right = minDepth(root->right);
        // 返回左/右 子树的最小深度并加1（观察题目中给出的最小深度定义）
        if (root->right == nullptr && root->left != nullptr) {
            return left + 1;
        } else if (root->right != nullptr && root->left == nullptr) {
            return right + 1;
        } else {
            return min(left, right) + 1;
        }
        
    }
};
```

## 完全二叉树的节点个数

给出一个完全二叉树，求出该树的节点个数。

### 完全二叉树的节点个数思路

- 确定遍历顺序（后序遍历）（因为要将左右子节点的信息，放到中间节点进行处理）
- 递归的三部曲
- 终止条件--当节点为空节点时，返回0
- 递归逻辑 -- 中间节点返回左右子树的总节点个数并加一
- 传入/出参数--节点与左右节点与自身单个节点的个数之和
- 根据完全二叉树的特性来解题（若子树是完全二叉树，那么就无需遍历上层节点，套用满二叉树的定义可得）

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int countNodes(TreeNode* root) {
        if (root == nullptr) return 0;
        int left_num = countNodes(root->left);
        int right_num = countNodes(root->right);
        return left_num + right_num + 1;
        
    }
};


// 完全二叉树的思路
class Solution {
public:
    int countNodes(TreeNode* root) {
        if (root == nullptr) return 0;
        TreeNode* left = root->left;
        TreeNode* right = root->right;
        int leftDepth = 0, rightDepth = 0; // 这里初始为0是有目的的，为了下面求指数方便
        while (left) {  // 求左子树深度
            left = left->left;
            leftDepth++;
        }
        while (right) { // 求右子树深度
            right = right->right;
            rightDepth++;
        }
        if (leftDepth == rightDepth) {
            return (2 << leftDepth) - 1; // 注意(2<<1) 相当于2^2，所以leftDepth初始为0
        }
        return countNodes(root->left) + countNodes(root->right) + 1;
    }
};
```

## 平衡二叉树

给定一个二叉树，判断它是否是高度平衡的二叉树。

### 平衡二叉树思路

- 确定遍历顺序（后序遍历）
- 递归的三部曲
- 对高度是否相差大于一进行判断，若大于1返回-1
- 终止条件--当节点为空节点时，返回0
- 递归逻辑 -- 中间节点返回左右子树的高度差，若大于1则为-1，不大于返回子树的最大深度
- 传入/出参数--节点与左右子树的最大深度加1

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int getHeight(TreeNode* cur) {
        if (cur == nullptr) return 0;
        int leftDepth = getHeight(cur->left);
        if (leftDepth == -1) return -1;
        int rightDepth = getHeight(cur->right);
        if (rightDepth == -1) return -1;
        if (abs(leftDepth - rightDepth) > 1) return -1;
        return max(leftDepth, rightDepth) + 1;
    }
    bool isBalanced(TreeNode* root) {
        int result = getHeight(root);
        if (result == -1) return false;
        return true;
    }
};
```

## 二叉树的所有路径

给定一个二叉树，返回所有从根节点到叶子节点的路径。

### 二叉树的所有路径思路

- 确定遍历顺序（前序遍历）
- 递归的三部曲
- 终止条件--遍历到叶子节点（左右节点都为空）返回
- 递归逻辑 -- 将该节点加入到result中
- 传入/出参数--节点与路径列表

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void traversal(TreeNode* root, vector<string>& result, vector<int>& path) {
        // 由于递归终止条件发生变化，因此在终止之前，先把叶子节点加入到path中
        path.push_back(root->val);
        // 若该节点为叶子节点，则处理path添加到路径当中
        if (root->left == nullptr && root->right == nullptr) {
            string sPath;
            for (int i = 0; i < path.size() - 1; i++) {
                sPath += to_string(path[i]);
                sPath += "->";
            }
            sPath += to_string(path[path.size() - 1]);
            result.push_back(sPath);
            return;
        }
        // 左子树进行递归
        if (root->left != nullptr) {
            traversal(root->left, result, path);
            // 由于使用同一个path，因此要对path进行回溯，返回到上一层级
            path.pop_back();
        }
        // 右子树进行递归
        if (root->right != nullptr) {
            traversal(root->right, result, path);
            // 由于使用同一个path，因此要对path进行回溯，返回到上一层级
            path.pop_back();
        }
    }
    vector<string> binaryTreePaths(TreeNode* root) {
        vector<string> result;
        vector<int> path;
        traversal(root, result, path);
        return result;
    }
};
```

## 左叶子之和

给定二叉树的根节点 root ，返回所有左叶子之和。

### 左叶子之和思路

- 确定遍历顺序（后序遍历）
- 递归的三部曲  
- 终止条件--当该节点的左子树不为空，且左子树的左右子树均为空，则为左叶子
- 递归逻辑 -- 将该左子树的值进行累加(对左叶子的父节点进行处理)
- 传入/传出参数 -- 节点,result

思路： 由于后序遍历，先确定递归条件，若当前节点为空则返回0；
向左递归，向右递归，进行处理，若该节点的左子树不为空，同时左子树的左子树和右子树为空，则返回左子树的value值；

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        if (root == nullptr) return 0;
        // 减少一层递归
        if (root->left == nullptr && root->right == nullptr) return 0;
        int leftSum = sumOfLeftLeaves(root->left);
        int rightSum = sumOfLeftLeaves(root->right);
        if (root->left != nullptr && root->left->left == nullptr && 
        root->left->right == nullptr) leftSum = root->left->val;
        return leftSum + rightSum;

    }
};
```

## 找树左下角的值

给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。

假设二叉树中至少有一个节点。

### 找树左下角的值思路

- 优先进行左侧遍历，使用后序遍历
- 本质是遍历整个子树，并找到depth最深的那层，当找到时，由于我们优先遍历左边，因此得到的值肯定是最下层的第一个叶子节点

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int maxDepth = INT_MIN;
    int result = 0;
    void traversal(TreeNode* root, int depth) {
        // 本质是遍历整个子树，并找到depth最深的那层，当找到时，由于我们优先遍历左边
        // 肯定为最下层的第一个叶子节点
        if (root->left == nullptr && root->right == nullptr) {
            // 遇到叶子节点，对depth进行更新
            if (depth > maxDepth) {
                maxDepth = depth;
                result = root->val;
            }
            return;
        };
        // 遍历左侧，隐含回溯
        if (root->left != nullptr) {
            depth++;
            traversal(root->left, depth);
            depth--;
        }
        // 遍历右侧，隐含回溯
        if(root->right != nullptr) {
            depth++;
            traversal(root->right, depth);
            depth--;
        }
        return;
        
    }
    int findBottomLeftValue(TreeNode* root) {
        traversal(root, 0);
        return result;
    }
};
```

## 路径总和

给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。

叶子节点 是指没有子节点的节点。

### 路径总和思路

- 遍历顺序（由于不涉及对中间节点的处理，处理顺序不重要）
- 递归的三部曲
- 终止条件--当节点为叶子节点且count为零时，返回True
- 递归逻辑 -- 若当前节点为叶子节点，则判断当前节点值是否等于targetSum，若等于则返回true，否则返回false
- 包含回溯逻辑

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool traversal(TreeNode* cur, int count) {
        // 递归返回条件
        if (cur->left == nullptr && cur->right == nullptr
        && count == 0) return true;
        if (cur->left == nullptr && cur->right == nullptr
        && count != 0) return false;
        
        // 向左遍历
        if (cur->left != nullptr)  {
            bool leftBool = traversal(cur->left, count - cur->left->val);
            if(leftBool) return true;
        }
        // 向右遍历
        if (cur->right != nullptr) {
            bool rightBool = traversal(cur->right, count - cur->right->val);
            if (rightBool) return true;
        }

        // 若两边均为false
        return false;
        

    }
    bool hasPathSum(TreeNode* root, int targetSum) {
        // 由于递归中没用对空节点的操作，因此设置空节点的判断
        if (root == nullptr) return false;
        // 由于减去当前节点的值，包含在左右递归的过程，因此要在root递归时，将target-root->val
        return traversal(root, targetSum - root->val);
    }
};
```

## 从中序与后序遍历序列构造二叉树

给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。

### 从中序与后序遍历序列构造二叉树思路

- 根据中序与后序的规律找到相对应的位置
- 首先后序（左右中）最后一个节点就是根节点
- 然后根据根节点的位置，可以基于中序确定左右子树的大小
- 递归的三部曲
- 终止条件--当节点为空时，返回空节点
- 递归逻辑 -- 先确定根节点，然后依次遍历左子树与右子树(中序数组大小一定是和后序数组的大小相同的（这是必然）。)
- 细节：确定区间定义的统一

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* traversal(vector<int>& inorder, vector<int>& postorder) {
        // 如果后序为零，则返回空节点
        if (postorder.size() == 0) return nullptr;
        // 取出后序的最后一个值，构造节点，若后序大小为1，叶子节点直接返回
        int mid = postorder[postorder.size() - 1];
        TreeNode* root = new TreeNode(mid);
        if (postorder.size() == 1) return root;
        // 在中序中，寻找根节点
        int index;
        for (index = 0;index < inorder.size(); index++) {
            if (inorder[index] == mid) {
                break;
            }
        }
        // 构造左右子树的中序与后序遍历
        // 中序数组
        vector<int> leftInorder(inorder.begin(), inorder.begin() + index);
        vector<int> rightInorder(inorder.begin() + index + 1, 
        inorder.end());
        // 后序数组
        postorder.resize(postorder.size() - 1); // 去掉最后一个数值（已使用，无用）
        vector<int> leftPostorder(postorder.begin(), postorder.begin() + leftInorder.size());
        vector<int> rightPostorder(postorder.begin() + leftInorder.size(),
        postorder.end());

        // 进行递归
        root->left = traversal(leftInorder, leftPostorder);
        root->right = traversal(rightInorder, rightPostorder);

        return root;

    }

    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        return traversal(inorder, postorder);
    }
};
```

## 最大二叉树

给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建:

创建一个根节点，其值为 nums 中的最大值。
递归地在最大值 左边 的 子数组前缀上 构建左子树。
递归地在最大值 右边 的 子数组后缀上 构建右子树。
返回 nums 构建的 最大二叉树 。

### 最大二叉树思路

- 确定遍历顺序（前序遍历）
- 递归的三部曲  
- 可以选择size为1，或size为0
- 确定区间划分的依据（左闭右开，还是左闭右闭），保持统一

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* construct(vector<int>& nums, int left, int right) {
        // 如果size为0（左闭右开）,返回空节点
        if (right <= left) return nullptr;
        // 采取前序遍历
        int maxIndex = left;
        // 寻找最大值-下标
        for (int index = left + 1; index < right; index++) {
            if (nums[index] > nums[maxIndex]) {
                maxIndex = index;
            }
        }
        TreeNode* cur = new TreeNode(nums[maxIndex]);
        // 向左遍历
        cur->left = construct(nums, left, maxIndex);
        // 向右遍历
        cur->right = construct(nums, maxIndex + 1, right);
        return cur;
    }
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        // 左开右闭, 因此传入参数为nums.size()
        return construct(nums, 0, nums.size());
    }
};
```

## 合并二叉树

给你两棵二叉树： root1 和 root2 。

想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。

返回合并后的二叉树。

注意: 合并过程必须从两个树的根节点开始。

### 合并二叉树思路

- 确定遍历顺序（先序遍历）
- 递归的三部曲  
- 终止条件--当两个树的节点均为空时，返回空节点
- 递归逻辑 -- 若两个节点均不为空，则创建新节点，并将值设置为两个节点的和，然后递归地将左右子树合并（
- 不为空的节点直接作为新二叉树的节点）
- 细节：合并过程必须从两个树的根节点开始。

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
        // 直接在tree1的基础上进行更改(若各节点有一个为空，那么剩下的子树结构直接套用过来即可，相当于剪枝)
        if (root1 == nullptr) return root2;
        if (root2 == nullptr) return root1;
        // 中间节点
        root1->val += root2->val;
        // 向左遍历
        root1->left = mergeTrees(root1->left, root2->left);
        // 向右遍历
        root1->right = mergeTrees(root1->right, root2->right);
        return root1;
    }
};
```

## 二叉搜索树中的搜索

给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。

- 二叉搜索树是一个有序树：
若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
它的左、右子树也分别为二叉搜索树
这就决定了，二叉搜索树，递归遍历和迭代遍历和普通二叉树都不一样。

### 二叉搜索树中的搜索思路

- 无需遍历顺序，基于二叉搜索树的特性即可确定遍历方向
- 递归的三部曲
- 终止条件--当节点为空/节点值等于目标值时，返回节点
- 递归逻辑--当节点值大于目标值->左子树遍历  当节点值小于目标值->右子树遍历
- 细节：二叉搜索树的特性，左子树小于根节点，右子树大于根节点，因此可以确定遍历方向

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        if (root == nullptr || root->val == val) {
            return root;
        }
        // 定义一个空指针，接收结果
        TreeNode* result = nullptr;
        
        if (root->val > val) { // 大于，则右子树遍历
            result = searchBST(root->left, val);
        } else { // 小于，则左子树遍历
            result = searchBST(root->right, val);
        }
        return result;

    }
};
```

## 验证二叉搜索树

给定一个二叉树，判断其是否是一个有效的二叉搜索树。

假设一个二叉搜索树具有如下特征：

节点的左子树**只包含小于当前节点的数。**
节点的右子树**只包含大于当前节点的数。**
所有左子树和右子树自身必须也是二叉搜索树。

### 验证二叉搜索树思路

- 二叉搜索树的特性--中序遍历得到一个递增序列
- 确定遍历顺序（中序遍历）
- 两种思路 --
  - 1.定义一个最小值，并在遍历过程中继续更新这个值，若这个值不递增，则返回false
  - 2.定义节点指针，始终保持着前一个节点，若该节点的值不小于下一个节点，返回false

第一种思路

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    long long maxValue = LONG_MIN;
    bool isValidBST(TreeNode* root) {
        // 采用中序遍历（基于二叉搜索树的特性）
        // 终止逻辑，遇到空节点 不是递增序列
        if (root == nullptr) return true;
        
        vector<int> result;
        // 向左遍历
        bool leftBool = isValidBST(root->left);
        if (root->val > maxValue) {
            maxValue = root->val;
        } else {
            return false;
        }
        
        // 向右遍历
        bool rightBool = isValidBST(root->right);
        return leftBool && rightBool;

    }
};
```

第二种思路

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* pre = nullptr;
    bool isValidBST(TreeNode* root) {
        // 采用中序遍历（基于二叉搜索树的特性）
        // 终止逻辑，遇到空节点 不是递增序列
        if (root == nullptr) return true;
        
        vector<int> result;
        // 向左遍历
        bool leftBool = isValidBST(root->left);
        if (pre != nullptr && root->val < pre->val) {
            return false;
        }
        pre = root;
        
        // 向右遍历
        bool rightBool = isValidBST(root->right);
        return leftBool && rightBool;

    }
};
```

## 二叉搜索树的最小绝对差

给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值 。

差值是一个正数，其数值等于两值之差的绝对值。

### 二叉搜索树的最小绝对差思路

- 递归，双指针（采用中序遍历<-二叉搜索树）

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* pre = nullptr;
    int minValue = INT_MAX;
    void traversal(TreeNode* cur) {
        if (cur == nullptr) return;
        // 向左遍历
        traversal(cur->left);
        // 中间处理
        if (pre != nullptr) {
            minValue = min(minValue, abs(pre->val - cur->val));
        }
        // 更新当前值
        pre = cur;
        // 向右遍历
        traversal(cur->right);

    }
    int getMinimumDifference(TreeNode* root) {
        
        traversal(root);
        return minValue;
    }
};
```

## 二叉搜索树中的众数

给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。

假定 BST 有如下定义：

结点左子树中所含结点的值小于等于当前结点的值
结点右子树中所含结点的值大于等于当前结点的值
左子树和右子树都是二叉搜索树

### 二叉搜索树中的众数思路

- 递归，双指针（采用中序遍历<-二叉搜索树）
- 对于结果集进行实时更新，若频率为当前最大并且频率相等，则加入结果
- 若不是，并且当前频率大于最大频率，清空结果集，并加入新元素

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* pre = nullptr;
    int count, maxCount;
    
    void traversal(TreeNode* cur, vector<int>& result) {
        if (cur != nullptr) return;
        // 向左遍历
        traversal(cur->left, result);
        // 如果pre为空，则只把节点的值记作1
        if (pre == nullptr) {
            count = 1;
            result.push_back(cur->val);
        } else if (pre->val == cur->val) {
            // 不为空，判断前后节点是否相等
            count++;
        }
        pre = root;
        // 判断count与最大频率的区别
        if (count == maxCount) result.push_back(cur->val);
        if (count > maxCount) {
            result.clear();
            maxCount = count;
            result.push_back(cur->val);
        }
        // 向右遍历
        traversal(cur->right, result);

    }
    vector<int> findMode(TreeNode* root) {
        // 由于设置了全局变量，先对参数进行重置操作
        count = 0;
        maxCount = 0;
        pre = nullptr;
        vector<int> result;
        traversal(root, result);
        return result;
    }
};
```

## 二叉树的最近公共祖先

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

### 二叉树的最近公共祖先思路

- 递归，由于目标可能放在最下层的节点，由最下层返回信息，到中间节点进行集中处理，因此采取后序遍历
- 递归三部曲
- 终止条件--1.节点为空 2. 该节点等于目标值之一，返回目标节点
- Attention : 存在子节点与目标节点是父子节点的状态，但这个逻辑也能进行处理（公共祖先必然存在）
  
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == NULL) return root;
        if (root == p || root == q) return root;
        // 采取后序遍历 向左遍历
        TreeNode* leftNode = lowestCommonAncestor(root->left, p, q);
        // 向右遍历
        TreeNode* rightNode = lowestCommonAncestor(root->right, p, q);
        // 中间节点处理逻辑
        if (leftNode != NULL && rightNode != NULL) return root;
        else if (leftNode == NULL && rightNode != NULL) return rightNode;
        else if (leftNode != NULL && rightNode == NULL) return leftNode;
        else return NULL;
    }
};
```

## 二叉搜索树的最近公共祖先

给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

### 二叉搜索树的最近公共祖先思路

跟二叉树的最近公共祖先思路一致，但相比较而言，要利用二叉搜索树的特性（有方向的进行递归，剪枝操作）

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */

class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == NULL) return root;
        // 有方向的进行递归操作
        if (root->val > p->val && root->val > q->val) {
            // 向左遍历
            TreeNode* leftNode = lowestCommonAncestor(root->left, p, q);
            if (leftNode != NULL) return leftNode;
        } else if (root->val < p->val && root->val < q->val) {
            // 向右遍历
            TreeNode* rightNode = lowestCommonAncestor(root->right, p, q);
            if (rightNode != NULL) return rightNode;
        } 
        return root;


    }
};
```

## 二叉搜索树中的插入操作

给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。

注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。

### 二叉搜索树中的插入操作思路

由于存在多种插入方式，同时无论任何值，都可以插到叶子节点；因此采取将值插入到对应的叶子节点处
递归法--小于当前节点，左递归；大于则右递归，直到当前节点为空时，将节点插入到该处

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        if (root == nullptr) {
            // 遇到空节点，则返回
            TreeNode* cur = new TreeNode(val);
            return cur;
        }
        // 向左遍历
        if (root->val > val) root->left = insertIntoBST(root->left, val);
        // 向右遍历
        if (root->val < val) root->right = insertIntoBST(root->right, val);
        // 层层接收
        return root;
    }
};
```

## 删除二叉搜索树中的节点

给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。

一般来说，删除节点可分为两个步骤：

首先找到需要删除的节点；
如果找到了，删除它。

### 删除二叉搜索树中的节点思路

- 确定删除节点后的几种情况
  - 未找到删除
  - 节点为叶子节点（最好处理）
  - 删除节点，左为空，右不为空
  - 删除节点，左不为空，右为空
  - 左不为空，右不为空
- 递归删除节点
- 递归三部曲
- 根据五种情况，判断递归终止条件
  - 第一种：未找到返回空指针
  - 第二种：节点为叶子节点，直接删除，返回空指针
  - 第三种：左为空，右不为空，返回该节点的右孩子进行接替
  - 第四种：左不为空，右为空，返回该节点的左孩子进行接替
  - 第五种：左不为空，右不为空，删除该节点后，对该子树进行单独处理，将左子树（均比该节点要小），移动到右子树的叶子节点处

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        if (root == nullptr) return root;
        if (root->val == key) {
            if (root->left == nullptr && root->right == nullptr) {
                delete root;
                return nullptr;// 删除节点为叶子节点
            } else if (root->right == nullptr) {
                TreeNode* cur = root->left;
                delete root;
                return cur;// 删除节点左孩子不为空，右孩子为空
            } else if (root->left == nullptr) {
                TreeNode* cur = root->right;
                delete root;
                return cur;// 删除节点右孩子为空，左孩子不为空
            } else {
                // 左右节点均不为空
                TreeNode* cur = root->right;
                // 寻找右节点的左叶子节点
                while (cur->left != nullptr) {
                    cur = cur->left;
                }
                cur->left = root->left;
                cur = root->right;
                delete root;
                return cur;

            }
        }
        // 进行递归操作
        if (root->val > key) {
            root->left = deleteNode(root->left, key); 
        }
        if (root->val < key) {
            root->right = deleteNode(root->right, key);
        }
        return root;
    }
};
```

## 修剪二叉搜索树

给定一个二叉搜索树，同时给定最小边界L 和最大边界 R。通过修剪二叉搜索树，使得所有节点的值在[L, R]中 (R>=L) 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。

### 修建二叉搜索树思路

- 递归法（对于二叉搜索树，应是有方向性的递归）
- 若该节点的值大于High，则右子树不必保留，将左子树继续递归操作
- 若该节点的值小于Low，则左子树不必保留，将右子树继续递归操作
- 终止条件，遇到的节点为空，返回上一层

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* trimBST(TreeNode* root, int low, int high) {
        if (root == nullptr) return root;
        if (root->val < low) {
            // 对右子树进行修剪，左子树去除
            return trimBST(root->right, low, high);
        } 
        if (root->val > high) {
            // 对左子树进行修剪，右子树去除
            return trimBST(root->left, low, high);
        }
        // 向左遍历
        root->left = trimBST(root->left, low, high);
        // 向右遍历
        root->right = trimBST(root->right, low, high);
        // 返回节点到上一层递归
        return root;
    }
};
```

## 将有序数组转换为二叉搜索树

给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 平衡 二叉搜索树。

### 将有序数组转换为二叉搜索树思路

- 由于是升序数组，因为采取中序的递归，建造二叉树
- 采取下标进行迭代，防止多次复制数组，造成内存空间浪费

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* traversal(vector<int>& nums, int left, int right) {
        // 采取左闭右闭的区间定义
        if (left > right) return nullptr;
        // 创建该子树下的根节点
        int mid = (left + right) / 2; // 选择左侧为中间节点
        TreeNode* root = new TreeNode(nums[mid]);
        // 向左遍历
        root->left = traversal(nums, left, mid - 1);
        // 向右遍历
        root->right = traversal(nums, mid + 1, right);

        // 返回节点到上一层
        return root;
    }
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        TreeNode* root = traversal(nums, 0, nums.size() - 1);
        return root;
    }
};
```

## 把二叉搜索树转换为累加树

给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。

提醒一下，二叉搜索树满足下列约束条件：

节点的左子树仅包含键 小于 节点键的节点。 节点的右子树仅包含键 大于 节点键的节点。 左右子树也必须是二叉搜索树。

### 把二叉搜索树转换为累加树思路

- 采用双指针的方法，由于将大于该值节点的值进行累加，因此要从右子树的叶子节点开始出发（右中左）
- 递归三部曲
- 终止条件，遇到空节点开始返回上一层
- 递归中，更新节点值，采取将上一个节点的值进行累加，逐步递增

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* pre = nullptr;
    void traversal(TreeNode* root) {
        if (root == nullptr) return;
        traversal(root->right); // 向右遍历
        if (pre != nullptr) root->val += pre->val;
        pre = root;
        traversal(root->left); // 向左遍历

    }
    TreeNode* convertBST(TreeNode* root) {
        
        traversal(root);
        return root;
    }
};
```

## 遍历顺序

涉及到二叉树的构造，无论普通二叉树还是二叉搜索树一定前序，都是先构造中节点。

求普通二叉树的属性，一般是后序，一般要通过递归函数的返回值做计算。

求二叉搜索树的属性，一定是中序了，要不白瞎了有序性了。

注意在普通二叉树的属性中，我用的是一般为后序，例如单纯求深度就用前序，二叉树：找所有路径 (opens new window)也用了前序，这是为了方便让父节点指向子节点。
